"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ImageVulnerability, VulnerabilitySummary } from "@/lib/api";
import { TrendingUp, TrendingDown, Minus, AlertTriangle, Calendar } from "lucide-react";
import { useState, useMemo } from "react";

interface VulnerabilityTrendChartProps {
  vulnerabilities: ImageVulnerability[];
  summary: VulnerabilitySummary;
  className?: string;
}

type TimeRange = "7d" | "30d" | "90d" | "all";

interface TrendDataPoint {
  date: string;
  critical: number;
  high: number;
  medium: number;
  low: number;
  total: number;
}

const severityColors = {
  critical: "#ef4444",
  high: "#f97316",
  medium: "#f59e0b",
  low: "#6b7280",
};

export function VulnerabilityTrendChart({
  vulnerabilities,
  summary,
  className,
}: VulnerabilityTrendChartProps) {
  const [timeRange, setTimeRange] = useState<TimeRange>("30d");

  // Calculate trend data from vulnerabilities
  const trendData = useMemo(() => {
    const now = new Date();
    const cutoff = new Date();

    switch (timeRange) {
      case "7d":
        cutoff.setDate(now.getDate() - 7);
        break;
      case "30d":
        cutoff.setDate(now.getDate() - 30);
        break;
      case "90d":
        cutoff.setDate(now.getDate() - 90);
        break;
      default:
        cutoff.setFullYear(now.getFullYear() - 1);
    }

    // Group vulnerabilities by date
    const byDate = new Map<string, TrendDataPoint>();

    // Get filtered vulns
    const filteredVulns = vulnerabilities.filter(
      (v) => new Date(v.createdAt) >= cutoff
    );

    // Initialize dates in range
    const dayCount = timeRange === "7d" ? 7 : timeRange === "30d" ? 30 : timeRange === "90d" ? 90 : 90;
    for (let i = dayCount; i >= 0; i--) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split("T")[0];
      byDate.set(dateStr, {
        date: dateStr,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        total: 0,
      });
    }

    // Count vulnerabilities by date and severity
    filteredVulns.forEach((vuln) => {
      const dateStr = new Date(vuln.createdAt).toISOString().split("T")[0];
      const point = byDate.get(dateStr);
      if (point) {
        point.total++;
        switch (vuln.severity) {
          case "critical":
            point.critical++;
            break;
          case "high":
            point.high++;
            break;
          case "medium":
            point.medium++;
            break;
          case "low":
            point.low++;
            break;
        }
      }
    });

    // Convert to cumulative counts (running total of open vulns)
    const sortedDates = Array.from(byDate.keys()).sort();
    let runningCritical = 0;
    let runningHigh = 0;
    let runningMedium = 0;
    let runningLow = 0;

    const data: TrendDataPoint[] = sortedDates.map((dateStr) => {
      const point = byDate.get(dateStr)!;
      runningCritical += point.critical;
      runningHigh += point.high;
      runningMedium += point.medium;
      runningLow += point.low;
      return {
        date: dateStr,
        critical: runningCritical,
        high: runningHigh,
        medium: runningMedium,
        low: runningLow,
        total: runningCritical + runningHigh + runningMedium + runningLow,
      };
    });

    return data;
  }, [vulnerabilities, timeRange]);

  // Calculate trend direction
  const calculateTrend = () => {
    if (trendData.length < 2) return { direction: "neutral" as const, change: 0 };
    const firstPoint = trendData[0];
    const lastPoint = trendData[trendData.length - 1];
    const change = lastPoint.total - firstPoint.total;
    return {
      direction: change > 0 ? "up" : change < 0 ? "down" : "neutral",
      change: Math.abs(change),
    };
  };

  const trend = calculateTrend();
  const maxValue = Math.max(...trendData.map((d) => d.total), 1);

  // Simple SVG chart
  const chartWidth = 600;
  const chartHeight = 200;
  const padding = { top: 20, right: 20, bottom: 30, left: 40 };
  const innerWidth = chartWidth - padding.left - padding.right;
  const innerHeight = chartHeight - padding.top - padding.bottom;

  const xScale = (index: number) =>
    padding.left + (index / (trendData.length - 1 || 1)) * innerWidth;
  const yScale = (value: number) =>
    padding.top + innerHeight - (value / maxValue) * innerHeight;

  // Generate path data for each severity
  const generatePath = (severity: "critical" | "high" | "medium" | "low") => {
    if (trendData.length === 0) return "";
    return trendData
      .map((point, i) => {
        const x = xScale(i);
        const y = yScale(point[severity]);
        return `${i === 0 ? "M" : "L"} ${x} ${y}`;
      })
      .join(" ");
  };

  // Generate area path (filled)
  const generateAreaPath = (severity: "critical" | "high" | "medium" | "low") => {
    if (trendData.length === 0) return "";
    const linePath = generatePath(severity);
    const lastX = xScale(trendData.length - 1);
    const firstX = xScale(0);
    const bottomY = yScale(0);
    return `${linePath} L ${lastX} ${bottomY} L ${firstX} ${bottomY} Z`;
  };

  return (
    <Card className={className}>
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2 text-base">
            <AlertTriangle className="h-4 w-4" />
            Vulnerability Trend
          </CardTitle>
          <div className="flex items-center gap-2">
            <Badge
              variant={trend.direction === "up" ? "destructive" : trend.direction === "down" ? "default" : "secondary"}
              className="flex items-center gap-1"
            >
              {trend.direction === "up" && <TrendingUp className="h-3 w-3" />}
              {trend.direction === "down" && <TrendingDown className="h-3 w-3" />}
              {trend.direction === "neutral" && <Minus className="h-3 w-3" />}
              {trend.direction === "up" ? "+" : trend.direction === "down" ? "-" : ""}
              {trend.change}
            </Badge>
            <Select value={timeRange} onValueChange={(v) => setTimeRange(v as TimeRange)}>
              <SelectTrigger className="w-[100px] h-8 text-xs">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="7d">7 days</SelectItem>
                <SelectItem value="30d">30 days</SelectItem>
                <SelectItem value="90d">90 days</SelectItem>
                <SelectItem value="all">All time</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        {/* SVG Chart */}
        <div className="w-full overflow-x-auto">
          <svg
            viewBox={`0 0 ${chartWidth} ${chartHeight}`}
            className="w-full h-[200px]"
            preserveAspectRatio="xMidYMid meet"
          >
            {/* Grid lines */}
            {[0, 0.25, 0.5, 0.75, 1].map((ratio) => (
              <g key={ratio}>
                <line
                  x1={padding.left}
                  y1={yScale(maxValue * ratio)}
                  x2={chartWidth - padding.right}
                  y2={yScale(maxValue * ratio)}
                  stroke="hsl(var(--border))"
                  strokeDasharray="4 4"
                  opacity={0.5}
                />
                <text
                  x={padding.left - 5}
                  y={yScale(maxValue * ratio)}
                  textAnchor="end"
                  dominantBaseline="middle"
                  className="fill-muted-foreground text-[10px]"
                >
                  {Math.round(maxValue * ratio)}
                </text>
              </g>
            ))}

            {/* Area fills (stacked) */}
            <path
              d={generateAreaPath("critical")}
              fill={severityColors.critical}
              opacity={0.2}
            />
            <path
              d={generateAreaPath("high")}
              fill={severityColors.high}
              opacity={0.15}
            />
            <path
              d={generateAreaPath("medium")}
              fill={severityColors.medium}
              opacity={0.1}
            />
            <path
              d={generateAreaPath("low")}
              fill={severityColors.low}
              opacity={0.1}
            />

            {/* Lines */}
            <path
              d={generatePath("critical")}
              fill="none"
              stroke={severityColors.critical}
              strokeWidth={2}
            />
            <path
              d={generatePath("high")}
              fill="none"
              stroke={severityColors.high}
              strokeWidth={2}
            />
            <path
              d={generatePath("medium")}
              fill="none"
              stroke={severityColors.medium}
              strokeWidth={2}
            />
            <path
              d={generatePath("low")}
              fill="none"
              stroke={severityColors.low}
              strokeWidth={2}
            />

            {/* X-axis labels (show subset) */}
            {trendData
              .filter((_, i) => i % Math.ceil(trendData.length / 6) === 0 || i === trendData.length - 1)
              .map((point, i, arr) => {
                const originalIndex = trendData.findIndex((p) => p.date === point.date);
                return (
                  <text
                    key={point.date}
                    x={xScale(originalIndex)}
                    y={chartHeight - 10}
                    textAnchor="middle"
                    className="fill-muted-foreground text-[10px]"
                  >
                    {new Date(point.date).toLocaleDateString("en-US", {
                      month: "short",
                      day: "numeric",
                    })}
                  </text>
                );
              })}
          </svg>
        </div>

        {/* Legend */}
        <div className="flex items-center justify-center gap-6 mt-4 text-xs">
          <div className="flex items-center gap-1.5">
            <div
              className="w-3 h-3 rounded-sm"
              style={{ backgroundColor: severityColors.critical }}
            />
            <span>Critical ({summary.criticalOpen})</span>
          </div>
          <div className="flex items-center gap-1.5">
            <div
              className="w-3 h-3 rounded-sm"
              style={{ backgroundColor: severityColors.high }}
            />
            <span>High ({summary.highOpen})</span>
          </div>
          <div className="flex items-center gap-1.5">
            <div
              className="w-3 h-3 rounded-sm"
              style={{ backgroundColor: severityColors.medium }}
            />
            <span>Medium ({summary.mediumOpen})</span>
          </div>
          <div className="flex items-center gap-1.5">
            <div
              className="w-3 h-3 rounded-sm"
              style={{ backgroundColor: severityColors.low }}
            />
            <span>Low ({summary.lowOpen})</span>
          </div>
        </div>

        {/* Summary footer */}
        <div className="flex items-center justify-between mt-4 pt-4 border-t text-sm">
          <div className="flex items-center gap-2 text-muted-foreground">
            <Calendar className="h-4 w-4" />
            Last scanned:{" "}
            {summary.lastScannedAt
              ? new Date(summary.lastScannedAt).toLocaleDateString()
              : "Never"}
          </div>
          <Badge variant="outline">
            {summary.fixedCount} fixed
          </Badge>
        </div>
      </CardContent>
    </Card>
  );
}
