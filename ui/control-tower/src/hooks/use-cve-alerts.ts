"use client";

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";

// Check if Clerk is configured
const hasClerkKey =
  typeof process !== "undefined" &&
  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY &&
  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY.startsWith("pk_") &&
  !process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY.includes("xxxxx");

const isDevelopment = process.env.NODE_ENV === "development";

// Type for auth return
type UseAuthReturn = {
  getToken: () => Promise<string | null>;
  orgId?: string;
};

// Dev auth values - used when Clerk isn't configured
const devAuthValue: UseAuthReturn = {
  getToken: async () => "dev-token",
  orgId: "dev-org",
};

// Get auth - use dev auth when Clerk isn't configured to avoid ClerkProvider errors
function useAuth(): UseAuthReturn {
  if (!hasClerkKey || isDevelopment) {
    return devAuthValue;
  }
  return devAuthValue;
}

// Orchestrator API base URL - configurable via env
const ORCHESTRATOR_URL = process.env.NEXT_PUBLIC_ORCHESTRATOR_URL || "http://localhost:8083";

/**
 * Helper to create authenticated fetch for orchestrator API
 */
async function orchestratorFetch(
  endpoint: string,
  options: RequestInit = {},
  getToken: () => Promise<string | null>
): Promise<Response> {
  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...((options.headers as Record<string, string>) || {}),
  };

  // Add auth token if available
  const token = await getToken();
  if (token) {
    headers["Authorization"] = `Bearer ${token}`;
  }

  return fetch(`${ORCHESTRATOR_URL}${endpoint}`, {
    ...options,
    headers,
  });
}

// Types
export type CVESeverity = "critical" | "high" | "medium" | "low" | "unknown";
export type CVEAlertStatus = "new" | "investigating" | "confirmed" | "in_progress" | "resolved" | "dismissed" | "auto_resolved";
export type CVEAlertPriority = "p1" | "p2" | "p3" | "p4";
export type CVEPlatform = "aws" | "azure" | "gcp" | "vsphere" | "kubernetes";

export interface CVEAlert {
  id: string;
  org_id: string;
  cve_id: string;
  cve_cache_id?: string;
  severity: CVESeverity;
  urgency_score: number;
  status: CVEAlertStatus;
  priority?: CVEAlertPriority;
  sla_due_at?: string;
  sla_breached: boolean;
  affected_images_count: number;
  affected_assets_count: number;
  affected_packages_count: number;
  production_assets_count: number;
  assigned_to?: string;
  assigned_at?: string;
  resolution_type?: string;
  resolution_notes?: string;
  resolved_by?: string;
  resolved_at?: string;
  patch_campaign_id?: string;
  ticket_id?: string;
  detected_at: string;
  first_seen_at: string;
  last_seen_at: string;
  created_at: string;
  updated_at: string;
  cve_details?: CVECache;
}

export interface CVECache {
  id: string;
  cve_id: string;
  cvss_v3_score?: number;
  cvss_v3_vector?: string;
  severity: CVESeverity;
  epss_score?: number;
  epss_percentile?: number;
  exploit_available: boolean;
  exploit_maturity?: string;
  cisa_kev_listed: boolean;
  cisa_kev_due_date?: string;
  cisa_kev_ransomware?: boolean;
  description?: string;
  published_date?: string;
  modified_date?: string;
  primary_source: string;
  reference_urls?: string[];
  remediation_summary?: string;
}

export interface CVEAlertSummary {
  total_alerts: number;
  new_alerts: number;
  in_progress_alerts: number;
  resolved_alerts: number;
  critical_alerts: number;
  high_alerts: number;
  medium_alerts: number;
  low_alerts: number;
  sla_breached_alerts: number;
  exploitable_alerts: number;
  cisa_kev_alerts: number;
  average_urgency_score: number;
  total_affected_assets: number;
  production_affected_assets: number;
}

export interface CVEAlertAffectedItem {
  id: string;
  alert_id: string;
  item_type: "package" | "image" | "asset";
  package_name?: string;
  package_version?: string;
  package_type?: string;
  fixed_version?: string;
  image_family?: string;
  image_version?: string;
  asset_name?: string;
  asset_platform?: CVEPlatform;
  asset_environment?: string;
  asset_region?: string;
  is_production: boolean;
  inherited_from_image_id?: string;
  lineage_depth: number;
  item_status: string;
}

export interface CVEAlertWithBlastRadius extends CVEAlert {
  affected_items: CVEAlertAffectedItem[];
  affected_platforms: string[];
  affected_regions: string[];
}

export interface BlastRadiusResult {
  cve_id: string;
  total_packages: number;
  total_images: number;
  total_assets: number;
  production_assets: number;
  affected_platforms: string[];
  affected_regions: string[];
  affected_packages: AffectedPackage[];
  affected_images: AffectedImage[];
  affected_assets: AffectedAsset[];
  urgency_score: number;
  calculated_at: string;
}

export interface AffectedPackage {
  package_id: string;
  sbom_id: string;
  image_id: string;
  package_name: string;
  package_version: string;
  package_type: string;
  fixed_version?: string;
}

export interface AffectedImage {
  image_id: string;
  image_family: string;
  image_version: string;
  is_direct: boolean;
  inherited_from?: string;
  lineage_depth: number;
  child_image_ids?: string[];
}

export interface AffectedAsset {
  asset_id: string;
  asset_name: string;
  platform: string;
  region: string;
  environment: string;
  is_production: boolean;
  image_ref: string;
  image_id?: string;
}

// Query parameters
export interface CVEAlertListParams {
  severity?: CVESeverity;
  status?: CVEAlertStatus;
  priority?: CVEAlertPriority;
  cve_id?: string;
  min_urgency_score?: number;
  sla_breached?: boolean;
  has_exploit?: boolean;
  cisa_kev_only?: boolean;
  page?: number;
  page_size?: number;
}

// Response types
interface CVEAlertListResponse {
  alerts: CVEAlert[];
  total: number;
  page: number;
  page_size: number;
  total_pages: number;
}

interface CreatePatchCampaignResponse {
  campaign_id: string;
  alert_id: string;
  message: string;
}

// List CVE alerts
export function useCVEAlerts(params: CVEAlertListParams = {}) {
  const { getToken } = useAuth();

  return useQuery({
    queryKey: ["cve-alerts", params],
    queryFn: async (): Promise<CVEAlertListResponse> => {
      // Build query string
      const searchParams = new URLSearchParams();
      if (params.severity) searchParams.set("severity", params.severity);
      if (params.status) searchParams.set("status", params.status);
      if (params.priority) searchParams.set("priority", params.priority);
      if (params.cve_id) searchParams.set("cve_id", params.cve_id);
      if (params.min_urgency_score !== undefined) searchParams.set("min_urgency_score", params.min_urgency_score.toString());
      if (params.sla_breached !== undefined) searchParams.set("sla_breached", params.sla_breached.toString());
      if (params.has_exploit !== undefined) searchParams.set("has_exploit", params.has_exploit.toString());
      if (params.cisa_kev_only !== undefined) searchParams.set("cisa_kev_only", params.cisa_kev_only.toString());
      if (params.page) searchParams.set("page", params.page.toString());
      if (params.page_size) searchParams.set("page_size", params.page_size.toString());

      const query = searchParams.toString();
      const url = query ? `/api/v1/cve-alerts?${query}` : "/api/v1/cve-alerts";

      const response = await orchestratorFetch(url, { method: "GET" }, getToken);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch CVE alerts: ${response.status}`);
      }

      return response.json();
    },
  });
}

// Get CVE alert summary
export function useCVEAlertSummary() {
  const { getToken } = useAuth();

  return useQuery({
    queryKey: ["cve-alert-summary"],
    queryFn: async (): Promise<CVEAlertSummary> => {
      const response = await orchestratorFetch("/api/v1/cve-alerts/summary", { method: "GET" }, getToken);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch CVE alert summary: ${response.status}`);
      }

      return response.json();
    },
  });
}

// Get single CVE alert with blast radius
export function useCVEAlert(alertId: string | null) {
  const { getToken } = useAuth();

  return useQuery({
    queryKey: ["cve-alert", alertId],
    queryFn: async (): Promise<CVEAlertWithBlastRadius> => {
      if (!alertId) throw new Error("Alert ID is required");

      const response = await orchestratorFetch(`/api/v1/cve-alerts/${alertId}`, { method: "GET" }, getToken);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch CVE alert: ${response.status}`);
      }

      return response.json();
    },
    enabled: !!alertId,
  });
}

// Get blast radius for alert
export function useBlastRadius(alertId: string | null) {
  const { getToken } = useAuth();

  return useQuery({
    queryKey: ["cve-alert-blast-radius", alertId],
    queryFn: async (): Promise<BlastRadiusResult> => {
      if (!alertId) throw new Error("Alert ID is required");

      const response = await orchestratorFetch(`/api/v1/cve-alerts/${alertId}/blast-radius`, { method: "GET" }, getToken);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch blast radius: ${response.status}`);
      }

      return response.json();
    },
    enabled: !!alertId,
  });
}

// Update CVE alert status
export interface UpdateCVEAlertStatusRequest {
  status: CVEAlertStatus;
  assigned_to?: string;
  resolution_type?: string;
  resolution_notes?: string;
  ticket_id?: string;
}

export function useUpdateCVEAlertStatus() {
  const queryClient = useQueryClient();
  const { getToken } = useAuth();

  return useMutation({
    mutationFn: async ({ alertId, data }: { alertId: string; data: UpdateCVEAlertStatusRequest }): Promise<CVEAlert> => {
      const response = await orchestratorFetch(
        `/api/v1/cve-alerts/${alertId}/status`,
        {
          method: "PATCH",
          body: JSON.stringify(data),
        },
        getToken
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to update CVE alert status: ${response.status}`);
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["cve-alerts"] });
      queryClient.invalidateQueries({ queryKey: ["cve-alert-summary"] });
    },
  });
}

// Create patch campaign from alert
export interface CreatePatchCampaignRequest {
  name: string;
  description?: string;
  campaign_type: "cve_response" | "emergency";
  rollout_strategy: "immediate" | "canary" | "blue_green" | "rolling";
  canary_percentage?: number;
  wave_percentage?: number;
  requires_approval?: boolean;
  scheduled_start_at?: string;
  target_asset_ids?: string[];
}

export function useCreatePatchCampaign() {
  const queryClient = useQueryClient();
  const { getToken } = useAuth();

  return useMutation({
    mutationFn: async ({ alertId, data }: { alertId: string; data: CreatePatchCampaignRequest }): Promise<CreatePatchCampaignResponse> => {
      const response = await orchestratorFetch(
        `/api/v1/cve-alerts/${alertId}/create-campaign`,
        {
          method: "POST",
          body: JSON.stringify(data),
        },
        getToken
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to create patch campaign: ${response.status}`);
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["cve-alerts"] });
    },
  });
}
