// Package integration contains end-to-end flow tests for the vulnerability response system.
// These tests verify the complete flow: CVE Detection → Blast Radius → Patch Campaign → Rollback
// Run with: go test -tags=integration ./tests/integration/... -run TestVulnerabilityFlow
package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"testing"
	"time"

	"github.com/google/uuid"
)

// TestVulnerabilityFlow_CVEAlertLifecycle tests the complete CVE alert lifecycle
// from creation to resolution.
func TestVulnerabilityFlow_CVEAlertLifecycle(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E flow test in short mode")
	}

	orchestratorURL := getEnv("TEST_ORCHESTRATOR_URL", "http://localhost:8083")
	orgID := getEnv("TEST_ORG_ID", "11111111-1111-1111-1111-111111111111")

	// Step 1: Get initial summary to establish baseline
	t.Log("Step 1: Getting initial CVE alert summary...")
	summaryURL := fmt.Sprintf("%s/api/v1/cve-alerts/summary", orchestratorURL)
	resp, body := makeFlowRequest(t, "GET", summaryURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Failed to get initial summary: %d - %s", resp.StatusCode, string(body))
	}

	var initialSummary CVEAlertSummary
	if err := json.Unmarshal(body, &initialSummary); err != nil {
		t.Fatalf("Failed to parse summary: %v", err)
	}
	t.Logf("Initial state: %d total alerts, %d new, %d resolved",
		initialSummary.TotalAlerts, initialSummary.NewAlerts, initialSummary.ResolvedAlerts)

	// Step 2: List alerts and find one in "new" status
	t.Log("Step 2: Finding a new alert to process...")
	listURL := fmt.Sprintf("%s/api/v1/cve-alerts?status=new&page_size=1", orchestratorURL)
	resp, body = makeFlowRequest(t, "GET", listURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Skipf("No alerts available: %d - %s", resp.StatusCode, string(body))
	}

	var listResult CVEAlertListResponse
	if err := json.Unmarshal(body, &listResult); err != nil {
		t.Fatalf("Failed to parse list: %v", err)
	}

	if len(listResult.Alerts) == 0 {
		t.Skip("No new alerts available for lifecycle test")
	}

	alert := listResult.Alerts[0]
	t.Logf("Selected alert: %s (CVE: %s, Severity: %s)", alert.ID, alert.CVEID, alert.Severity)

	// Step 3: Get alert details
	t.Log("Step 3: Getting alert details...")
	detailURL := fmt.Sprintf("%s/api/v1/cve-alerts/%s", orchestratorURL, alert.ID)
	resp, body = makeFlowRequest(t, "GET", detailURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Failed to get alert detail: %d - %s", resp.StatusCode, string(body))
	}

	var alertDetail CVEAlert
	if err := json.Unmarshal(body, &alertDetail); err != nil {
		t.Fatalf("Failed to parse alert: %v", err)
	}
	t.Logf("Alert details - Urgency: %.1f, Affected Assets: %d, Production: %d",
		alertDetail.UrgencyScore, alertDetail.AffectedAssetsCount, alertDetail.ProductionAssetsCount)

	// Step 4: Calculate blast radius
	t.Log("Step 4: Calculating blast radius...")
	blastURL := fmt.Sprintf("%s/api/v1/cve-alerts/%s/blast-radius", orchestratorURL, alert.ID)
	resp, body = makeFlowRequest(t, "GET", blastURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Logf("Blast radius not available: %d (may be expected for mock data)", resp.StatusCode)
	} else {
		var blastRadius BlastRadiusResult
		if err := json.Unmarshal(body, &blastRadius); err == nil {
			t.Logf("Blast radius - Packages: %d, Images: %d, Assets: %d (Prod: %d)",
				blastRadius.TotalPackages, blastRadius.TotalImages,
				blastRadius.TotalAssets, blastRadius.ProductionAssets)
		}
	}

	// Step 5: Transition alert to "investigating" status
	t.Log("Step 5: Transitioning to investigating status...")
	investigateURL := fmt.Sprintf("%s/api/v1/cve-alerts/%s/investigate", orchestratorURL, alert.ID)
	investigateReq := map[string]interface{}{
		"assigned_to": "e2e-test-user",
		"notes":       "E2E flow test - investigating alert",
	}
	resp, body = makeFlowRequest(t, "POST", investigateURL, investigateReq, orgID)

	// Accept 200 (success), 409 (already transitioned), or 400 (validation)
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusConflict && resp.StatusCode != http.StatusBadRequest {
		t.Fatalf("Unexpected status on investigate: %d - %s", resp.StatusCode, string(body))
	}
	t.Logf("Investigate transition: status %d", resp.StatusCode)

	// Step 6: Get updated summary
	t.Log("Step 6: Verifying summary updated...")
	resp, body = makeFlowRequest(t, "GET", summaryURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Failed to get updated summary: %d", resp.StatusCode)
	}

	var finalSummary CVEAlertSummary
	if err := json.Unmarshal(body, &finalSummary); err != nil {
		t.Fatalf("Failed to parse final summary: %v", err)
	}
	t.Logf("Final state: %d total, %d new, %d in-progress",
		finalSummary.TotalAlerts, finalSummary.NewAlerts, finalSummary.InProgressAlerts)

	t.Log("CVE Alert Lifecycle flow completed successfully")
}

// TestVulnerabilityFlow_PatchCampaignCreation tests creating a patch campaign from a CVE alert.
func TestVulnerabilityFlow_PatchCampaignCreation(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E flow test in short mode")
	}

	orchestratorURL := getEnv("TEST_ORCHESTRATOR_URL", "http://localhost:8083")
	orgID := getEnv("TEST_ORG_ID", "11111111-1111-1111-1111-111111111111")

	// Step 1: Find a CVE alert to create a campaign from
	t.Log("Step 1: Finding CVE alerts...")
	listURL := fmt.Sprintf("%s/api/v1/cve-alerts?page_size=1", orchestratorURL)
	resp, body := makeFlowRequest(t, "GET", listURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Skipf("No CVE alerts available: %d", resp.StatusCode)
	}

	var alertList CVEAlertListResponse
	if err := json.Unmarshal(body, &alertList); err != nil {
		t.Fatalf("Failed to parse alerts: %v", err)
	}

	var cveAlertID string
	var cveName string
	if len(alertList.Alerts) > 0 {
		cveAlertID = alertList.Alerts[0].ID
		cveName = alertList.Alerts[0].CVEID
		t.Logf("Using CVE alert: %s (%s)", cveAlertID, cveName)
	}

	// Step 2: Create a patch campaign
	t.Log("Step 2: Creating patch campaign...")
	campaignName := fmt.Sprintf("E2E Test Campaign - %s - %d", cveName, time.Now().Unix())
	createReq := map[string]interface{}{
		"name":                         campaignName,
		"description":                  "Automated E2E test patch campaign",
		"campaign_type":                "cve_response",
		"cve_alert_ids":                []string{cveAlertID},
		"rollout_strategy":             "canary",
		"canary_percentage":            5,
		"wave_percentage":              25,
		"failure_threshold_percentage": 5,
		"health_check_enabled":         true,
		"auto_rollback_enabled":        true,
		"requires_approval":            true,
	}

	createURL := fmt.Sprintf("%s/api/v1/patch-campaigns", orchestratorURL)
	resp, body = makeFlowRequest(t, "POST", createURL, createReq, orgID)

	// Accept 201 (created) or 400 (missing required data like target assets)
	if resp.StatusCode != http.StatusCreated && resp.StatusCode != http.StatusBadRequest {
		t.Fatalf("Unexpected create status: %d - %s", resp.StatusCode, string(body))
	}

	if resp.StatusCode == http.StatusCreated {
		var campaign PatchCampaign
		if err := json.Unmarshal(body, &campaign); err != nil {
			t.Fatalf("Failed to parse campaign: %v", err)
		}
		t.Logf("Created campaign: %s (ID: %s, Status: %s)", campaign.Name, campaign.ID, campaign.Status)

		// Step 3: Verify campaign appears in list
		t.Log("Step 3: Verifying campaign in list...")
		campaignListURL := fmt.Sprintf("%s/api/v1/patch-campaigns", orchestratorURL)
		resp, body = makeFlowRequest(t, "GET", campaignListURL, nil, orgID)
		if resp.StatusCode != http.StatusOK {
			t.Fatalf("Failed to list campaigns: %d", resp.StatusCode)
		}

		var campaignList PatchCampaignListResponse
		if err := json.Unmarshal(body, &campaignList); err != nil {
			t.Fatalf("Failed to parse campaign list: %v", err)
		}

		found := false
		for _, c := range campaignList.Campaigns {
			if c.ID == campaign.ID {
				found = true
				break
			}
		}
		if !found {
			t.Error("Created campaign not found in list")
		}

		// Step 4: Get campaign phases
		t.Log("Step 4: Getting campaign phases...")
		phasesURL := fmt.Sprintf("%s/api/v1/patch-campaigns/%s/phases", orchestratorURL, campaign.ID)
		resp, body = makeFlowRequest(t, "GET", phasesURL, nil, orgID)
		if resp.StatusCode == http.StatusOK {
			var phases PatchCampaignPhasesResponse
			if err := json.Unmarshal(body, &phases); err == nil {
				t.Logf("Campaign has %d phases", len(phases.Phases))
			}
		}

		t.Logf("Patch campaign creation flow completed - Campaign ID: %s", campaign.ID)
	} else {
		t.Log("Campaign creation returned 400 - likely missing required assets (expected for minimal test data)")
	}
}

// TestVulnerabilityFlow_CampaignApprovalWorkflow tests the campaign approval workflow.
func TestVulnerabilityFlow_CampaignApprovalWorkflow(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E flow test in short mode")
	}

	orchestratorURL := getEnv("TEST_ORCHESTRATOR_URL", "http://localhost:8083")
	orgID := getEnv("TEST_ORG_ID", "11111111-1111-1111-1111-111111111111")

	// Find a campaign pending approval
	t.Log("Step 1: Finding campaign pending approval...")
	listURL := fmt.Sprintf("%s/api/v1/patch-campaigns?status=pending_approval&page_size=1", orchestratorURL)
	resp, body := makeFlowRequest(t, "GET", listURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Skipf("Cannot list campaigns: %d", resp.StatusCode)
	}

	var campaignList PatchCampaignListResponse
	if err := json.Unmarshal(body, &campaignList); err != nil {
		t.Fatalf("Failed to parse list: %v", err)
	}

	if len(campaignList.Campaigns) == 0 {
		// Try to find any campaign that requires approval
		listURL = fmt.Sprintf("%s/api/v1/patch-campaigns?page_size=10", orchestratorURL)
		resp, body = makeFlowRequest(t, "GET", listURL, nil, orgID)
		if err := json.Unmarshal(body, &campaignList); err != nil {
			t.Fatalf("Failed to parse list: %v", err)
		}

		// Find one requiring approval
		for _, c := range campaignList.Campaigns {
			if c.RequiresApproval && (c.Status == "draft" || c.Status == "pending_approval") {
				t.Logf("Found campaign requiring approval: %s (Status: %s)", c.Name, c.Status)
				testCampaignApproval(t, orchestratorURL, orgID, c.ID)
				return
			}
		}
		t.Skip("No campaigns requiring approval found")
	}

	campaign := campaignList.Campaigns[0]
	testCampaignApproval(t, orchestratorURL, orgID, campaign.ID)
}

func testCampaignApproval(t *testing.T, baseURL, orgID, campaignID string) {
	// Step 2: Attempt to approve
	t.Log("Step 2: Approving campaign...")
	approveURL := fmt.Sprintf("%s/api/v1/patch-campaigns/%s/approve", baseURL, campaignID)
	approveReq := map[string]interface{}{
		"approved_by": "e2e-test-approver",
		"notes":       "E2E flow test approval",
	}
	resp, body := makeFlowRequest(t, "POST", approveURL, approveReq, orgID)

	// Accept 200 (approved), 409 (already approved/wrong state), 400 (validation)
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusConflict && resp.StatusCode != http.StatusBadRequest {
		t.Fatalf("Unexpected approval status: %d - %s", resp.StatusCode, string(body))
	}
	t.Logf("Approval response: %d", resp.StatusCode)

	// Step 3: Get updated campaign status
	t.Log("Step 3: Verifying campaign status...")
	detailURL := fmt.Sprintf("%s/api/v1/patch-campaigns/%s", baseURL, campaignID)
	resp, body = makeFlowRequest(t, "GET", detailURL, nil, orgID)
	if resp.StatusCode == http.StatusOK {
		var campaign PatchCampaign
		if err := json.Unmarshal(body, &campaign); err == nil {
			t.Logf("Campaign status after approval attempt: %s", campaign.Status)
		}
	}

	t.Log("Campaign approval workflow completed")
}

// TestVulnerabilityFlow_CampaignRollbackScenario tests the rollback functionality.
func TestVulnerabilityFlow_CampaignRollbackScenario(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E flow test in short mode")
	}

	orchestratorURL := getEnv("TEST_ORCHESTRATOR_URL", "http://localhost:8083")
	orgID := getEnv("TEST_ORG_ID", "11111111-1111-1111-1111-111111111111")

	// Find an in-progress campaign to test rollback
	t.Log("Step 1: Finding in-progress campaign...")
	listURL := fmt.Sprintf("%s/api/v1/patch-campaigns?status=in_progress&page_size=1", orchestratorURL)
	resp, body := makeFlowRequest(t, "GET", listURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Skipf("Cannot list campaigns: %d", resp.StatusCode)
	}

	var campaignList PatchCampaignListResponse
	if err := json.Unmarshal(body, &campaignList); err != nil {
		t.Fatalf("Failed to parse list: %v", err)
	}

	if len(campaignList.Campaigns) == 0 {
		t.Skip("No in-progress campaigns available for rollback test")
	}

	campaign := campaignList.Campaigns[0]
	t.Logf("Testing rollback on campaign: %s (ID: %s)", campaign.Name, campaign.ID)

	// Step 2: Get current progress
	t.Log("Step 2: Getting current campaign progress...")
	progressURL := fmt.Sprintf("%s/api/v1/patch-campaigns/%s/progress", orchestratorURL, campaign.ID)
	resp, body = makeFlowRequest(t, "GET", progressURL, nil, orgID)
	if resp.StatusCode == http.StatusOK {
		var progress PatchCampaignProgress
		if err := json.Unmarshal(body, &progress); err == nil {
			t.Logf("Current progress: %.1f%% complete, %d completed, %d failed",
				progress.CompletionPercentage, progress.CompletedAssets, progress.FailedAssets)
		}
	}

	// Step 3: Attempt rollback
	t.Log("Step 3: Attempting rollback...")
	rollbackURL := fmt.Sprintf("%s/api/v1/patch-campaigns/%s/rollback", orchestratorURL, campaign.ID)
	rollbackReq := map[string]interface{}{
		"reason":     "E2E flow test - testing rollback functionality",
		"initiated_by": "e2e-test-user",
	}
	resp, body = makeFlowRequest(t, "POST", rollbackURL, rollbackReq, orgID)

	// Accept 200 (rollback started), 409 (already rolling back), 400 (validation)
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusAccepted &&
		resp.StatusCode != http.StatusConflict && resp.StatusCode != http.StatusBadRequest {
		t.Fatalf("Unexpected rollback status: %d - %s", resp.StatusCode, string(body))
	}
	t.Logf("Rollback response: %d", resp.StatusCode)

	// Step 4: Verify campaign status changed
	t.Log("Step 4: Verifying campaign status after rollback...")
	detailURL := fmt.Sprintf("%s/api/v1/patch-campaigns/%s", orchestratorURL, campaign.ID)
	resp, body = makeFlowRequest(t, "GET", detailURL, nil, orgID)
	if resp.StatusCode == http.StatusOK {
		var updatedCampaign PatchCampaign
		if err := json.Unmarshal(body, &updatedCampaign); err == nil {
			t.Logf("Campaign status after rollback attempt: %s", updatedCampaign.Status)
		}
	}

	t.Log("Campaign rollback scenario completed")
}

// TestVulnerabilityFlow_MultipleCVEsAffectingSameAsset tests correlation of multiple CVEs.
func TestVulnerabilityFlow_MultipleCVEsAffectingSameAsset(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E flow test in short mode")
	}

	orchestratorURL := getEnv("TEST_ORCHESTRATOR_URL", "http://localhost:8083")
	orgID := getEnv("TEST_ORG_ID", "11111111-1111-1111-1111-111111111111")

	// Get multiple CVE alerts
	t.Log("Step 1: Getting multiple CVE alerts...")
	listURL := fmt.Sprintf("%s/api/v1/cve-alerts?page_size=10", orchestratorURL)
	resp, body := makeFlowRequest(t, "GET", listURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Skipf("Cannot list alerts: %d", resp.StatusCode)
	}

	var alertList CVEAlertListResponse
	if err := json.Unmarshal(body, &alertList); err != nil {
		t.Fatalf("Failed to parse alerts: %v", err)
	}

	if len(alertList.Alerts) < 2 {
		t.Skip("Need at least 2 CVE alerts for correlation test")
	}

	t.Logf("Found %d CVE alerts to analyze", len(alertList.Alerts))

	// Analyze blast radius for each to find overlapping assets
	assetCVEMap := make(map[string][]string) // asset -> CVEs affecting it

	for _, alert := range alertList.Alerts {
		blastURL := fmt.Sprintf("%s/api/v1/cve-alerts/%s/blast-radius", orchestratorURL, alert.ID)
		resp, body = makeFlowRequest(t, "GET", blastURL, nil, orgID)
		if resp.StatusCode == http.StatusOK {
			var blast BlastRadiusResult
			if err := json.Unmarshal(body, &blast); err == nil {
				t.Logf("CVE %s affects %d assets", alert.CVEID, blast.TotalAssets)
			}
		}
	}

	// Check summary for total affected assets
	t.Log("Step 2: Getting summary for correlation analysis...")
	summaryURL := fmt.Sprintf("%s/api/v1/cve-alerts/summary", orchestratorURL)
	resp, body = makeFlowRequest(t, "GET", summaryURL, nil, orgID)
	if resp.StatusCode == http.StatusOK {
		var summary CVEAlertSummary
		if err := json.Unmarshal(body, &summary); err == nil {
			t.Logf("Total affected assets across all CVEs: %d (Production: %d)",
				summary.TotalAffectedAssets, summary.ProductionAffectedAssets)
		}
	}

	// Log correlation results
	for asset, cves := range assetCVEMap {
		if len(cves) > 1 {
			t.Logf("Asset %s affected by multiple CVEs: %v", asset, cves)
		}
	}

	t.Log("Multi-CVE correlation analysis completed")
}

// TestVulnerabilityFlow_EndToEnd tests the complete flow from CVE to campaign completion.
func TestVulnerabilityFlow_EndToEnd(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E flow test in short mode")
	}

	orchestratorURL := getEnv("TEST_ORCHESTRATOR_URL", "http://localhost:8083")
	orgID := getEnv("TEST_ORG_ID", "11111111-1111-1111-1111-111111111111")

	t.Log("=== Starting End-to-End Vulnerability Response Flow ===")

	// Phase 1: CVE Detection
	t.Log("\n--- Phase 1: CVE Detection ---")
	summaryURL := fmt.Sprintf("%s/api/v1/cve-alerts/summary", orchestratorURL)
	resp, body := makeFlowRequest(t, "GET", summaryURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Cannot get CVE summary: %d", resp.StatusCode)
	}
	var summary CVEAlertSummary
	json.Unmarshal(body, &summary)
	t.Logf("CVE Summary: %d total, %d critical, %d with exploit",
		summary.TotalAlerts, summary.CriticalAlerts, summary.ExploitableAlerts)

	// Phase 2: Find Critical Alert
	t.Log("\n--- Phase 2: Finding Critical CVE ---")
	criticalURL := fmt.Sprintf("%s/api/v1/cve-alerts?severity=critical&page_size=1", orchestratorURL)
	resp, body = makeFlowRequest(t, "GET", criticalURL, nil, orgID)
	if resp.StatusCode != http.StatusOK {
		t.Skip("No critical CVEs available")
	}
	var criticalList CVEAlertListResponse
	json.Unmarshal(body, &criticalList)
	if len(criticalList.Alerts) == 0 {
		// Fall back to any alert
		listURL := fmt.Sprintf("%s/api/v1/cve-alerts?page_size=1", orchestratorURL)
		resp, body = makeFlowRequest(t, "GET", listURL, nil, orgID)
		json.Unmarshal(body, &criticalList)
		if len(criticalList.Alerts) == 0 {
			t.Skip("No CVE alerts available")
		}
	}
	alert := criticalList.Alerts[0]
	t.Logf("Selected CVE: %s (Severity: %s, Urgency: %.1f)",
		alert.CVEID, alert.Severity, alert.UrgencyScore)

	// Phase 3: Blast Radius Analysis
	t.Log("\n--- Phase 3: Blast Radius Analysis ---")
	blastURL := fmt.Sprintf("%s/api/v1/cve-alerts/%s/blast-radius", orchestratorURL, alert.ID)
	resp, body = makeFlowRequest(t, "GET", blastURL, nil, orgID)
	if resp.StatusCode == http.StatusOK {
		var blast BlastRadiusResult
		json.Unmarshal(body, &blast)
		t.Logf("Blast Radius: %d packages, %d images, %d assets (%d production)",
			blast.TotalPackages, blast.TotalImages, blast.TotalAssets, blast.ProductionAssets)
	}

	// Phase 4: Check Patch Campaigns
	t.Log("\n--- Phase 4: Patch Campaign Summary ---")
	campaignSummaryURL := fmt.Sprintf("%s/api/v1/patch-campaigns/summary", orchestratorURL)
	resp, body = makeFlowRequest(t, "GET", campaignSummaryURL, nil, orgID)
	if resp.StatusCode == http.StatusOK {
		var campaignSummary PatchCampaignSummary
		json.Unmarshal(body, &campaignSummary)
		t.Logf("Campaign Summary: %d total, %d active, %d completed, %.1f%% success rate",
			campaignSummary.TotalCampaigns, campaignSummary.ActiveCampaigns,
			campaignSummary.CompletedCampaigns, campaignSummary.SuccessRate)
	}

	// Phase 5: List Active Campaigns
	t.Log("\n--- Phase 5: Active Campaigns ---")
	activeCampaignsURL := fmt.Sprintf("%s/api/v1/patch-campaigns?status=in_progress", orchestratorURL)
	resp, body = makeFlowRequest(t, "GET", activeCampaignsURL, nil, orgID)
	if resp.StatusCode == http.StatusOK {
		var activeList PatchCampaignListResponse
		json.Unmarshal(body, &activeList)
		t.Logf("Active campaigns: %d", len(activeList.Campaigns))
		for _, c := range activeList.Campaigns {
			t.Logf("  - %s: %s (Progress: %d/%d assets)",
				c.Name, c.Status, c.CompletedAssets, c.TotalAssets)
		}
	}

	t.Log("\n=== End-to-End Flow Completed Successfully ===")
}

// Helper function for flow tests
func makeFlowRequest(t *testing.T, method, url string, body interface{}, orgID string) (*http.Response, []byte) {
	t.Helper()

	var reqBody io.Reader
	if body != nil {
		jsonBody, err := json.Marshal(body)
		if err != nil {
			t.Fatalf("Failed to marshal request body: %v", err)
		}
		reqBody = bytes.NewReader(jsonBody)
	}

	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		t.Fatalf("Failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer dev-token")
	req.Header.Set("X-Org-ID", orgID)
	req.Header.Set("X-User-ID", uuid.New().String())

	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		t.Fatalf("Request failed: %v", err)
	}

	respBody, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		t.Fatalf("Failed to read response: %v", err)
	}

	return resp, respBody
}
