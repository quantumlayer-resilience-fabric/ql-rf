// Package integration contains integration tests for the vulnerability response system.
// Run with: go test -tags=integration ./tests/integration/... -run TestCVE
package integration

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"testing"
	"time"

	"github.com/google/uuid"
)

// Test configuration
var (
	orchestratorURL = getEnv("TEST_ORCHESTRATOR_URL", "http://localhost:8083")
	testOrgID       = getEnv("TEST_ORG_ID", "11111111-1111-1111-1111-111111111111")
)

func getEnv(key, fallback string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return fallback
}

// CVE Alert test structures
type CVEAlertSummary struct {
	TotalAlerts            int     `json:"total_alerts"`
	NewAlerts              int     `json:"new_alerts"`
	InProgressAlerts       int     `json:"in_progress_alerts"`
	ResolvedAlerts         int     `json:"resolved_alerts"`
	CriticalAlerts         int     `json:"critical_alerts"`
	HighAlerts             int     `json:"high_alerts"`
	MediumAlerts           int     `json:"medium_alerts"`
	LowAlerts              int     `json:"low_alerts"`
	SLABreachedAlerts      int     `json:"sla_breached_alerts"`
	ExploitableAlerts      int     `json:"exploitable_alerts"`
	CISAKEVAlerts          int     `json:"cisa_kev_alerts"`
	AverageUrgencyScore    float64 `json:"average_urgency_score"`
	TotalAffectedAssets    int     `json:"total_affected_assets"`
	ProductionAffectedAssets int   `json:"production_affected_assets"`
}

type CVEAlert struct {
	ID                   string    `json:"id"`
	OrgID                string    `json:"org_id"`
	CVEID                string    `json:"cve_id"`
	Severity             string    `json:"severity"`
	UrgencyScore         float64   `json:"urgency_score"`
	Status               string    `json:"status"`
	Priority             string    `json:"priority,omitempty"`
	SLADueAt             string    `json:"sla_due_at,omitempty"`
	SLABreached          bool      `json:"sla_breached"`
	AffectedImagesCount  int       `json:"affected_images_count"`
	AffectedAssetsCount  int       `json:"affected_assets_count"`
	AffectedPackagesCount int      `json:"affected_packages_count"`
	ProductionAssetsCount int      `json:"production_assets_count"`
	DetectedAt           string    `json:"detected_at"`
	CreatedAt            string    `json:"created_at"`
}

type CVEAlertListResponse struct {
	Alerts     []CVEAlert `json:"alerts"`
	Total      int        `json:"total"`
	Page       int        `json:"page"`
	PageSize   int        `json:"page_size"`
	TotalPages int        `json:"total_pages"`
}

type BlastRadiusResult struct {
	CVEID             string   `json:"cve_id"`
	TotalPackages     int      `json:"total_packages"`
	TotalImages       int      `json:"total_images"`
	TotalAssets       int      `json:"total_assets"`
	ProductionAssets  int      `json:"production_assets"`
	AffectedPlatforms []string `json:"affected_platforms"`
	AffectedRegions   []string `json:"affected_regions"`
	UrgencyScore      float64  `json:"urgency_score"`
	CalculatedAt      string   `json:"calculated_at"`
}

// Patch Campaign test structures
type PatchCampaignSummary struct {
	TotalCampaigns     int     `json:"total_campaigns"`
	ActiveCampaigns    int     `json:"active_campaigns"`
	CompletedCampaigns int     `json:"completed_campaigns"`
	FailedCampaigns    int     `json:"failed_campaigns"`
	TotalAssetsPatched int     `json:"total_assets_patched"`
	TotalRollbacks     int     `json:"total_rollbacks"`
	SuccessRate        float64 `json:"success_rate"`
}

type PatchCampaign struct {
	ID                        string   `json:"id"`
	OrgID                     string   `json:"org_id"`
	Name                      string   `json:"name"`
	Description               string   `json:"description,omitempty"`
	CampaignType              string   `json:"campaign_type"`
	CVEAlertIDs               []string `json:"cve_alert_ids,omitempty"`
	Status                    string   `json:"status"`
	RequiresApproval          bool     `json:"requires_approval"`
	RolloutStrategy           string   `json:"rollout_strategy"`
	CanaryPercentage          int      `json:"canary_percentage,omitempty"`
	WavePercentage            int      `json:"wave_percentage,omitempty"`
	FailureThresholdPercentage int     `json:"failure_threshold_percentage,omitempty"`
	HealthCheckEnabled        bool     `json:"health_check_enabled"`
	AutoRollbackEnabled       bool     `json:"auto_rollback_enabled"`
	TotalAssets               int      `json:"total_assets"`
	PendingAssets             int      `json:"pending_assets"`
	InProgressAssets          int      `json:"in_progress_assets"`
	CompletedAssets           int      `json:"completed_assets"`
	FailedAssets              int      `json:"failed_assets"`
	SkippedAssets             int      `json:"skipped_assets"`
	CreatedBy                 string   `json:"created_by"`
	CreatedAt                 string   `json:"created_at"`
}

type PatchCampaignListResponse struct {
	Campaigns  []PatchCampaign `json:"campaigns"`
	Total      int             `json:"total"`
	Page       int             `json:"page"`
	PageSize   int             `json:"page_size"`
	TotalPages int             `json:"total_pages"`
}

type PatchCampaignPhase struct {
	ID               string  `json:"id"`
	CampaignID       string  `json:"campaign_id"`
	PhaseNumber      int     `json:"phase_number"`
	Name             string  `json:"name"`
	PhaseType        string  `json:"phase_type"`
	TargetPercentage float64 `json:"target_percentage"`
	Status           string  `json:"status"`
	TotalAssets      int     `json:"total_assets"`
	CompletedAssets  int     `json:"completed_assets"`
	FailedAssets     int     `json:"failed_assets"`
	HealthCheckPassed *bool  `json:"health_check_passed,omitempty"`
}

type PatchCampaignPhasesResponse struct {
	CampaignID string               `json:"campaign_id"`
	Phases     []PatchCampaignPhase `json:"phases"`
}

type PatchCampaignProgress struct {
	CampaignID           string  `json:"campaign_id"`
	Status               string  `json:"status"`
	TotalAssets          int     `json:"total_assets"`
	CompletedAssets      int     `json:"completed_assets"`
	FailedAssets         int     `json:"failed_assets"`
	SkippedAssets        int     `json:"skipped_assets"`
	CompletionPercentage float64 `json:"completion_percentage"`
	FailurePercentage    float64 `json:"failure_percentage"`
	TotalPhases          int     `json:"total_phases"`
	CompletedPhases      int     `json:"completed_phases"`
	CurrentPhase         string  `json:"current_phase"`
	CurrentPhaseProgress float64 `json:"current_phase_progress"`
}

// Helper functions
func makeRequest(t *testing.T, method, url string, body interface{}) (*http.Response, []byte) {
	t.Helper()

	var reqBody io.Reader
	if body != nil {
		jsonBody, err := json.Marshal(body)
		if err != nil {
			t.Fatalf("Failed to marshal request body: %v", err)
		}
		reqBody = bytes.NewReader(jsonBody)
	}

	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		t.Fatalf("Failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer dev-token")
	req.Header.Set("X-Org-ID", testOrgID)

	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		t.Fatalf("Request failed: %v", err)
	}

	respBody, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		t.Fatalf("Failed to read response: %v", err)
	}

	return resp, respBody
}

// ============================================================================
// CVE Alert API Tests
// ============================================================================

func TestCVEAlerts_Summary(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	url := fmt.Sprintf("%s/api/v1/cve-alerts/summary", orchestratorURL)
	resp, body := makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var summary CVEAlertSummary
	if err := json.Unmarshal(body, &summary); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	// Validate response structure
	if summary.TotalAlerts < 0 {
		t.Error("TotalAlerts should be >= 0")
	}
	if summary.CriticalAlerts < 0 || summary.HighAlerts < 0 || summary.MediumAlerts < 0 || summary.LowAlerts < 0 {
		t.Error("Alert counts by severity should be >= 0")
	}
	if summary.AverageUrgencyScore < 0 || summary.AverageUrgencyScore > 100 {
		t.Errorf("AverageUrgencyScore should be between 0 and 100, got %f", summary.AverageUrgencyScore)
	}

	t.Logf("CVE Alert Summary: Total=%d, Critical=%d, High=%d, Medium=%d, Low=%d",
		summary.TotalAlerts, summary.CriticalAlerts, summary.HighAlerts, summary.MediumAlerts, summary.LowAlerts)
}

func TestCVEAlerts_List(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	url := fmt.Sprintf("%s/api/v1/cve-alerts", orchestratorURL)
	resp, body := makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var result CVEAlertListResponse
	if err := json.Unmarshal(body, &result); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	// Validate pagination
	if result.Page < 1 {
		t.Error("Page should be >= 1")
	}
	if result.PageSize < 1 {
		t.Error("PageSize should be >= 1")
	}

	t.Logf("CVE Alerts: Total=%d, Page=%d, PageSize=%d", result.Total, result.Page, result.PageSize)
}

func TestCVEAlerts_ListWithFilters(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	testCases := []struct {
		name   string
		params string
	}{
		{"by severity", "?severity=critical"},
		{"by status", "?status=new"},
		{"by min urgency", "?min_urgency_score=80"},
		{"by CISA KEV", "?cisa_kev_only=true"},
		{"by exploit", "?has_exploit=true"},
		{"paginated", "?page=1&page_size=5"},
		{"combined filters", "?severity=high&status=investigating&page=1"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			url := fmt.Sprintf("%s/api/v1/cve-alerts%s", orchestratorURL, tc.params)
			resp, body := makeRequest(t, "GET", url, nil)

			if resp.StatusCode != http.StatusOK {
				t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
			}

			var result CVEAlertListResponse
			if err := json.Unmarshal(body, &result); err != nil {
				t.Fatalf("Failed to unmarshal response: %v", err)
			}
		})
	}
}

func TestCVEAlerts_GetByID(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// First get list to find an alert ID
	listURL := fmt.Sprintf("%s/api/v1/cve-alerts?page_size=1", orchestratorURL)
	resp, body := makeRequest(t, "GET", listURL, nil)

	if resp.StatusCode != http.StatusOK {
		t.Skipf("No alerts available to test: %s", string(body))
	}

	var listResult CVEAlertListResponse
	if err := json.Unmarshal(body, &listResult); err != nil {
		t.Fatalf("Failed to unmarshal list response: %v", err)
	}

	if len(listResult.Alerts) == 0 {
		t.Skip("No alerts available to test")
	}

	alertID := listResult.Alerts[0].ID

	// Get the alert by ID
	url := fmt.Sprintf("%s/api/v1/cve-alerts/%s", orchestratorURL, alertID)
	resp, body = makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var alert CVEAlert
	if err := json.Unmarshal(body, &alert); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	if alert.ID != alertID {
		t.Errorf("Expected alert ID %s, got %s", alertID, alert.ID)
	}
}

func TestCVEAlerts_GetByID_NotFound(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	nonExistentID := uuid.New().String()
	url := fmt.Sprintf("%s/api/v1/cve-alerts/%s", orchestratorURL, nonExistentID)
	resp, _ := makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusNotFound {
		t.Errorf("Expected status 404, got %d", resp.StatusCode)
	}
}

func TestCVEAlerts_BlastRadius(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// First get list to find an alert ID
	listURL := fmt.Sprintf("%s/api/v1/cve-alerts?page_size=1", orchestratorURL)
	resp, body := makeRequest(t, "GET", listURL, nil)

	if resp.StatusCode != http.StatusOK {
		t.Skipf("No alerts available: %s", string(body))
	}

	var listResult CVEAlertListResponse
	if err := json.Unmarshal(body, &listResult); err != nil {
		t.Fatalf("Failed to unmarshal list response: %v", err)
	}

	if len(listResult.Alerts) == 0 {
		t.Skip("No alerts available to test blast radius")
	}

	alertID := listResult.Alerts[0].ID

	// Get blast radius
	url := fmt.Sprintf("%s/api/v1/cve-alerts/%s/blast-radius", orchestratorURL, alertID)
	resp, body = makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var blastRadius BlastRadiusResult
	if err := json.Unmarshal(body, &blastRadius); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	// Validate blast radius structure
	if blastRadius.TotalPackages < 0 {
		t.Error("TotalPackages should be >= 0")
	}
	if blastRadius.TotalImages < 0 {
		t.Error("TotalImages should be >= 0")
	}
	if blastRadius.TotalAssets < 0 {
		t.Error("TotalAssets should be >= 0")
	}
	if blastRadius.ProductionAssets > blastRadius.TotalAssets {
		t.Error("ProductionAssets should be <= TotalAssets")
	}
	if blastRadius.UrgencyScore < 0 || blastRadius.UrgencyScore > 100 {
		t.Errorf("UrgencyScore should be between 0 and 100, got %f", blastRadius.UrgencyScore)
	}

	t.Logf("Blast Radius: CVE=%s, Packages=%d, Images=%d, Assets=%d (Production=%d), Urgency=%.1f",
		blastRadius.CVEID, blastRadius.TotalPackages, blastRadius.TotalImages,
		blastRadius.TotalAssets, blastRadius.ProductionAssets, blastRadius.UrgencyScore)
}

func TestCVEAlerts_StatusTransitions(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Skip if no alerts available
	listURL := fmt.Sprintf("%s/api/v1/cve-alerts?status=new&page_size=1", orchestratorURL)
	resp, body := makeRequest(t, "GET", listURL, nil)

	if resp.StatusCode != http.StatusOK {
		t.Skipf("Cannot list alerts: %s", string(body))
	}

	var listResult CVEAlertListResponse
	if err := json.Unmarshal(body, &listResult); err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	if len(listResult.Alerts) == 0 {
		t.Skip("No new alerts available for status transition test")
	}

	alertID := listResult.Alerts[0].ID

	// Test investigate transition
	investigateURL := fmt.Sprintf("%s/api/v1/cve-alerts/%s/investigate", orchestratorURL, alertID)
	resp, body = makeRequest(t, "POST", investigateURL, map[string]interface{}{
		"assigned_to": "test-user",
	})

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusConflict {
		t.Errorf("Investigate: expected 200 or 409, got %d: %s", resp.StatusCode, string(body))
	}
}

// ============================================================================
// Patch Campaign API Tests
// ============================================================================

func TestPatchCampaigns_Summary(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	url := fmt.Sprintf("%s/api/v1/patch-campaigns/summary", orchestratorURL)
	resp, body := makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var summary PatchCampaignSummary
	if err := json.Unmarshal(body, &summary); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	// Validate response structure
	if summary.TotalCampaigns < 0 {
		t.Error("TotalCampaigns should be >= 0")
	}
	if summary.SuccessRate < 0 || summary.SuccessRate > 100 {
		t.Errorf("SuccessRate should be between 0 and 100, got %f", summary.SuccessRate)
	}

	t.Logf("Patch Campaign Summary: Total=%d, Active=%d, Completed=%d, Failed=%d, SuccessRate=%.1f%%",
		summary.TotalCampaigns, summary.ActiveCampaigns, summary.CompletedCampaigns,
		summary.FailedCampaigns, summary.SuccessRate)
}

func TestPatchCampaigns_List(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	url := fmt.Sprintf("%s/api/v1/patch-campaigns", orchestratorURL)
	resp, body := makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var result PatchCampaignListResponse
	if err := json.Unmarshal(body, &result); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	// Validate pagination
	if result.Page < 1 {
		t.Error("Page should be >= 1")
	}
	if result.PageSize < 1 {
		t.Error("PageSize should be >= 1")
	}

	t.Logf("Patch Campaigns: Total=%d, Page=%d, PageSize=%d", result.Total, result.Page, result.PageSize)
}

func TestPatchCampaigns_ListWithFilters(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	testCases := []struct {
		name   string
		params string
	}{
		{"by status in_progress", "?status=in_progress"},
		{"by status completed", "?status=completed"},
		{"by status pending_approval", "?status=pending_approval"},
		{"by campaign type", "?campaign_type=cve_response"},
		{"paginated", "?page=1&page_size=5"},
		{"combined", "?status=in_progress&page=1&page_size=10"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			url := fmt.Sprintf("%s/api/v1/patch-campaigns%s", orchestratorURL, tc.params)
			resp, body := makeRequest(t, "GET", url, nil)

			if resp.StatusCode != http.StatusOK {
				t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
			}

			var result PatchCampaignListResponse
			if err := json.Unmarshal(body, &result); err != nil {
				t.Fatalf("Failed to unmarshal response: %v", err)
			}
		})
	}
}

func TestPatchCampaigns_Create(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	createReq := map[string]interface{}{
		"name":                         fmt.Sprintf("Test Campaign %d", time.Now().Unix()),
		"description":                  "Integration test campaign",
		"campaign_type":                "scheduled",
		"rollout_strategy":             "canary",
		"canary_percentage":            5,
		"wave_percentage":              25,
		"failure_threshold_percentage": 5,
		"health_check_enabled":         true,
		"auto_rollback_enabled":        true,
		"requires_approval":            true,
	}

	url := fmt.Sprintf("%s/api/v1/patch-campaigns", orchestratorURL)
	resp, body := makeRequest(t, "POST", url, createReq)

	// Accept 201 Created or 400 Bad Request (if missing required data)
	if resp.StatusCode != http.StatusCreated && resp.StatusCode != http.StatusBadRequest {
		t.Fatalf("Expected status 201 or 400, got %d: %s", resp.StatusCode, string(body))
	}

	if resp.StatusCode == http.StatusCreated {
		var campaign PatchCampaign
		if err := json.Unmarshal(body, &campaign); err != nil {
			t.Fatalf("Failed to unmarshal response: %v", err)
		}

		if campaign.ID == "" {
			t.Error("Created campaign should have an ID")
		}
		if campaign.Name != createReq["name"] {
			t.Errorf("Expected name %s, got %s", createReq["name"], campaign.Name)
		}
		if campaign.RolloutStrategy != "canary" {
			t.Errorf("Expected rollout strategy canary, got %s", campaign.RolloutStrategy)
		}

		t.Logf("Created campaign: ID=%s, Name=%s", campaign.ID, campaign.Name)
	}
}

func TestPatchCampaigns_GetByID(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// First get list to find a campaign ID
	listURL := fmt.Sprintf("%s/api/v1/patch-campaigns?page_size=1", orchestratorURL)
	resp, body := makeRequest(t, "GET", listURL, nil)

	if resp.StatusCode != http.StatusOK {
		t.Skipf("No campaigns available: %s", string(body))
	}

	var listResult PatchCampaignListResponse
	if err := json.Unmarshal(body, &listResult); err != nil {
		t.Fatalf("Failed to unmarshal list response: %v", err)
	}

	if len(listResult.Campaigns) == 0 {
		t.Skip("No campaigns available to test")
	}

	campaignID := listResult.Campaigns[0].ID

	// Get the campaign by ID
	url := fmt.Sprintf("%s/api/v1/patch-campaigns/%s", orchestratorURL, campaignID)
	resp, body = makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var campaign PatchCampaign
	if err := json.Unmarshal(body, &campaign); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	if campaign.ID != campaignID {
		t.Errorf("Expected campaign ID %s, got %s", campaignID, campaign.ID)
	}
}

func TestPatchCampaigns_GetByID_NotFound(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	nonExistentID := uuid.New().String()
	url := fmt.Sprintf("%s/api/v1/patch-campaigns/%s", orchestratorURL, nonExistentID)
	resp, _ := makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusNotFound {
		t.Errorf("Expected status 404, got %d", resp.StatusCode)
	}
}

func TestPatchCampaigns_Phases(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// First get list to find a campaign ID
	listURL := fmt.Sprintf("%s/api/v1/patch-campaigns?page_size=1", orchestratorURL)
	resp, body := makeRequest(t, "GET", listURL, nil)

	if resp.StatusCode != http.StatusOK {
		t.Skipf("No campaigns available: %s", string(body))
	}

	var listResult PatchCampaignListResponse
	if err := json.Unmarshal(body, &listResult); err != nil {
		t.Fatalf("Failed to unmarshal list response: %v", err)
	}

	if len(listResult.Campaigns) == 0 {
		t.Skip("No campaigns available to test phases")
	}

	campaignID := listResult.Campaigns[0].ID

	// Get phases
	url := fmt.Sprintf("%s/api/v1/patch-campaigns/%s/phases", orchestratorURL, campaignID)
	resp, body = makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var phasesResp PatchCampaignPhasesResponse
	if err := json.Unmarshal(body, &phasesResp); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	if phasesResp.CampaignID != campaignID {
		t.Errorf("Expected campaign ID %s, got %s", campaignID, phasesResp.CampaignID)
	}

	t.Logf("Campaign %s has %d phases", campaignID, len(phasesResp.Phases))
}

func TestPatchCampaigns_Progress(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// First get list to find an active campaign
	listURL := fmt.Sprintf("%s/api/v1/patch-campaigns?status=in_progress&page_size=1", orchestratorURL)
	resp, body := makeRequest(t, "GET", listURL, nil)

	if resp.StatusCode != http.StatusOK {
		t.Skipf("Cannot list campaigns: %s", string(body))
	}

	var listResult PatchCampaignListResponse
	if err := json.Unmarshal(body, &listResult); err != nil {
		t.Fatalf("Failed to unmarshal list response: %v", err)
	}

	if len(listResult.Campaigns) == 0 {
		// Try any campaign
		listURL = fmt.Sprintf("%s/api/v1/patch-campaigns?page_size=1", orchestratorURL)
		resp, body = makeRequest(t, "GET", listURL, nil)
		if err := json.Unmarshal(body, &listResult); err != nil {
			t.Fatalf("Failed to unmarshal: %v", err)
		}
		if len(listResult.Campaigns) == 0 {
			t.Skip("No campaigns available to test progress")
		}
	}

	campaignID := listResult.Campaigns[0].ID

	// Get progress
	url := fmt.Sprintf("%s/api/v1/patch-campaigns/%s/progress", orchestratorURL, campaignID)
	resp, body = makeRequest(t, "GET", url, nil)

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	var progress PatchCampaignProgress
	if err := json.Unmarshal(body, &progress); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	// Validate progress structure
	if progress.CompletionPercentage < 0 || progress.CompletionPercentage > 100 {
		t.Errorf("CompletionPercentage should be between 0 and 100, got %f", progress.CompletionPercentage)
	}
	if progress.FailurePercentage < 0 || progress.FailurePercentage > 100 {
		t.Errorf("FailurePercentage should be between 0 and 100, got %f", progress.FailurePercentage)
	}

	t.Logf("Campaign %s Progress: Status=%s, Completion=%.1f%%, Phase=%s",
		campaignID, progress.Status, progress.CompletionPercentage, progress.CurrentPhase)
}

// ============================================================================
// Health Check
// ============================================================================

func TestOrchestratorHealth(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	url := fmt.Sprintf("%s/health", orchestratorURL)

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		t.Fatalf("Failed to create request: %v", err)
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		t.Fatalf("Health check failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		t.Fatalf("Expected status 200, got %d: %s", resp.StatusCode, string(body))
	}

	t.Log("Orchestrator health check passed")
}
