name: CD - Continuous Deployment

on:
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types: [completed]

  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
      skip_staging:
        description: 'Skip staging (production only)'
        required: false
        type: boolean
        default: false

env:
  HELM_VERSION: '3.13.0'
  KUBECTL_VERSION: 'v1.28.0'

jobs:
  # ============================================================================
  # Deployment Gate
  # ============================================================================
  check-ci:
    name: Verify CI Status
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Check CI result
        id: check
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.workflow_run.conclusion }}" == "success" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Deploy to Staging
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: check-ci
    if: needs.check-ci.outputs.should_deploy == 'true' && (github.event.inputs.environment == 'staging' || github.event.inputs.skip_staging != 'true')
    environment:
      name: staging
      url: https://staging.quantumlayer.dev
    outputs:
      deployment_id: ${{ steps.deploy.outputs.deployment_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Configure kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Get image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to staging
        id: deploy
        run: |
          DEPLOYMENT_ID=$(date +%Y%m%d%H%M%S)-${{ steps.tag.outputs.tag }}
          echo "deployment_id=${DEPLOYMENT_ID}" >> $GITHUB_OUTPUT

          helm upgrade --install ql-rf ./deploy/helm/ql-rf \
            --namespace ql-rf-staging \
            --create-namespace \
            --values ./deploy/helm/ql-rf/values.yaml \
            --set global.environment=staging \
            --set api.image.tag=${{ steps.tag.outputs.tag }} \
            --set orchestrator.image.tag=${{ steps.tag.outputs.tag }} \
            --set connectors.image.tag=${{ steps.tag.outputs.tag }} \
            --set drift.image.tag=${{ steps.tag.outputs.tag }} \
            --set ui.image.tag=${{ steps.tag.outputs.tag }} \
            --set global.deploymentId=${DEPLOYMENT_ID} \
            --wait \
            --timeout 10m

      - name: Verify deployment
        run: |
          echo "Waiting for deployments to be ready..."
          kubectl -n ql-rf-staging rollout status deployment/ql-rf-api --timeout=5m
          kubectl -n ql-rf-staging rollout status deployment/ql-rf-orchestrator --timeout=5m
          kubectl -n ql-rf-staging rollout status deployment/ql-rf-ui --timeout=5m

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."

          # Get service URLs
          API_URL=$(kubectl -n ql-rf-staging get ingress ql-rf-api -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "localhost")

          # Health checks
          max_attempts=10
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            if curl -sf "https://${API_URL}/healthz" > /dev/null 2>&1; then
              echo "API health check passed"
              break
            fi
            echo "Attempt $attempt/$max_attempts failed, retrying..."
            sleep 10
            attempt=$((attempt + 1))
          done

          if [ $attempt -gt $max_attempts ]; then
            echo "Smoke tests failed after $max_attempts attempts"
            exit 1
          fi

      - name: Notify Slack - Staging Success
        if: success()
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "‚úÖ QL-RF deployed to staging",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Successful*\n‚Ä¢ Version: `${{ steps.tag.outputs.tag }}`\n‚Ä¢ Deployment ID: `${{ steps.deploy.outputs.deployment_id }}`\n‚Ä¢ <https://staging.quantumlayer.dev|View Staging>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

  # ============================================================================
  # Integration Tests on Staging
  # ============================================================================
  staging-integration-tests:
    name: Staging Integration Tests
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          cache: true

      - name: Run integration tests
        env:
          RF_API_URL: https://staging-api.quantumlayer.dev
          RF_ORCHESTRATOR_URL: https://staging-api.quantumlayer.dev:8083
          RF_TEST_ORG_ID: ${{ secrets.TEST_ORG_ID }}
          RF_TEST_API_KEY: ${{ secrets.TEST_API_KEY }}
        run: |
          go test -tags=integration -v -timeout 15m ./tests/integration/...

  # ============================================================================
  # Canary Analysis
  # ============================================================================
  canary-analysis:
    name: Canary Analysis
    runs-on: ubuntu-latest
    needs: staging-integration-tests
    environment: staging

    steps:
      - name: Analyze canary metrics
        run: |
          echo "Analyzing canary metrics from staging..."

          # In production, this would query Prometheus/Datadog for:
          # - Error rates
          # - Latency percentiles
          # - Resource utilization

          echo "Canary analysis passed - proceeding to production gate"

  # ============================================================================
  # Production Approval Gate
  # ============================================================================
  production-approval:
    name: Production Approval
    runs-on: ubuntu-latest
    needs: [canary-analysis]
    environment:
      name: production-approval
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

    steps:
      - name: Approval received
        run: echo "Production deployment approved"

  # ============================================================================
  # Deploy to Production
  # ============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: production-approval
    if: github.event.inputs.environment == 'production' || needs.production-approval.result == 'success'
    environment:
      name: production
      url: https://app.quantumlayer.dev
    outputs:
      deployment_id: ${{ steps.deploy.outputs.deployment_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Configure kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Get image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Create change record
        id: change
        run: |
          CHANGE_ID="CHG-$(date +%Y%m%d%H%M%S)"
          echo "change_id=${CHANGE_ID}" >> $GITHUB_OUTPUT
          echo "Created change record: ${CHANGE_ID}"

      - name: Deploy canary (5%)
        id: canary
        run: |
          DEPLOYMENT_ID=$(date +%Y%m%d%H%M%S)-${{ steps.tag.outputs.tag }}
          echo "deployment_id=${DEPLOYMENT_ID}" >> $GITHUB_OUTPUT

          echo "Deploying canary (5% traffic)..."

          helm upgrade --install ql-rf-canary ./deploy/helm/ql-rf \
            --namespace ql-rf-production \
            --create-namespace \
            --values ./deploy/helm/ql-rf/values.yaml \
            --values ./deploy/helm/ql-rf/values-production.yaml \
            --set global.environment=production \
            --set global.canary.enabled=true \
            --set global.canary.weight=5 \
            --set api.image.tag=${{ steps.tag.outputs.tag }} \
            --set orchestrator.image.tag=${{ steps.tag.outputs.tag }} \
            --set connectors.image.tag=${{ steps.tag.outputs.tag }} \
            --set drift.image.tag=${{ steps.tag.outputs.tag }} \
            --set ui.image.tag=${{ steps.tag.outputs.tag }} \
            --set global.deploymentId=${DEPLOYMENT_ID} \
            --wait \
            --timeout 10m

      - name: Monitor canary (5 minutes)
        run: |
          echo "Monitoring canary deployment..."
          sleep 300

          # Check error rates
          echo "Checking canary health..."
          kubectl -n ql-rf-production get pods -l app.kubernetes.io/name=ql-rf-canary

      - name: Promote canary to 25%
        run: |
          echo "Promoting canary to 25%..."
          helm upgrade --install ql-rf-canary ./deploy/helm/ql-rf \
            --namespace ql-rf-production \
            --reuse-values \
            --set global.canary.weight=25 \
            --wait \
            --timeout 5m

          sleep 180

      - name: Promote canary to 50%
        run: |
          echo "Promoting canary to 50%..."
          helm upgrade --install ql-rf-canary ./deploy/helm/ql-rf \
            --namespace ql-rf-production \
            --reuse-values \
            --set global.canary.weight=50 \
            --wait \
            --timeout 5m

          sleep 180

      - name: Full rollout (100%)
        id: deploy
        run: |
          echo "Performing full rollout..."

          # Deploy stable release
          helm upgrade --install ql-rf ./deploy/helm/ql-rf \
            --namespace ql-rf-production \
            --values ./deploy/helm/ql-rf/values.yaml \
            --values ./deploy/helm/ql-rf/values-production.yaml \
            --set global.environment=production \
            --set api.image.tag=${{ steps.tag.outputs.tag }} \
            --set orchestrator.image.tag=${{ steps.tag.outputs.tag }} \
            --set connectors.image.tag=${{ steps.tag.outputs.tag }} \
            --set drift.image.tag=${{ steps.tag.outputs.tag }} \
            --set ui.image.tag=${{ steps.tag.outputs.tag }} \
            --set global.deploymentId=${{ steps.canary.outputs.deployment_id }} \
            --wait \
            --timeout 10m

          # Remove canary
          helm uninstall ql-rf-canary --namespace ql-rf-production || true

      - name: Verify production deployment
        run: |
          echo "Verifying production deployment..."
          kubectl -n ql-rf-production rollout status deployment/ql-rf-api --timeout=5m
          kubectl -n ql-rf-production rollout status deployment/ql-rf-orchestrator --timeout=5m
          kubectl -n ql-rf-production rollout status deployment/ql-rf-ui --timeout=5m

      - name: Run production smoke tests
        run: |
          echo "Running production smoke tests..."

          max_attempts=10
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            if curl -sf "https://api.quantumlayer.dev/healthz" > /dev/null 2>&1; then
              echo "Production health check passed"
              break
            fi
            echo "Attempt $attempt/$max_attempts failed, retrying..."
            sleep 10
            attempt=$((attempt + 1))
          done

          if [ $attempt -gt $max_attempts ]; then
            echo "Production smoke tests failed"
            exit 1
          fi

      - name: Notify Slack - Production Success
        if: success()
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "üöÄ QL-RF deployed to production",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment Successful*\n‚Ä¢ Version: `${{ steps.tag.outputs.tag }}`\n‚Ä¢ Change: `${{ steps.change.outputs.change_id }}`\n‚Ä¢ <https://app.quantumlayer.dev|View Production>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

  # ============================================================================
  # Rollback (Manual Trigger)
  # ============================================================================
  rollback:
    name: Rollback Production
    runs-on: ubuntu-latest
    if: failure() && needs.deploy-production.result == 'failure'
    needs: deploy-production
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Configure kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Rollback to previous version
        run: |
          echo "Rolling back production deployment..."
          helm rollback ql-rf -n ql-rf-production 0

          # Also clean up any canary
          helm uninstall ql-rf-canary -n ql-rf-production || true

      - name: Verify rollback
        run: |
          kubectl -n ql-rf-production rollout status deployment/ql-rf-api --timeout=5m
          kubectl -n ql-rf-production rollout status deployment/ql-rf-orchestrator --timeout=5m

      - name: Notify Slack - Rollback
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "‚ö†Ô∏è QL-RF production rollback executed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Rollback Executed*\n‚Ä¢ Reason: Deployment failure\n‚Ä¢ Action: Reverted to previous version\n‚Ä¢ <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
