// Package tools provides vulnerability management tools for the AI orchestrator.
package tools

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"

	"github.com/quantumlayerhq/ql-rf/services/orchestrator/internal/blastradius"
)

// =============================================================================
// CVE Alert Query Tools (Read-Only)
// =============================================================================

// ListCVEAlertsTool queries CVE alerts with filters.
type ListCVEAlertsTool struct {
	db *pgxpool.Pool
}

func (t *ListCVEAlertsTool) Name() string        { return "list_cve_alerts" }
func (t *ListCVEAlertsTool) Description() string { return "List CVE alerts with filters (severity, status, priority, days since detected)" }
func (t *ListCVEAlertsTool) Risk() RiskLevel     { return RiskReadOnly }
func (t *ListCVEAlertsTool) Scope() Scope        { return ScopeOrganization }
func (t *ListCVEAlertsTool) Idempotent() bool    { return true }
func (t *ListCVEAlertsTool) RequiresApproval() bool { return false }
func (t *ListCVEAlertsTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"severity":   map[string]interface{}{"type": "string", "enum": []string{"critical", "high", "medium", "low"}},
			"status":     map[string]interface{}{"type": "string", "enum": []string{"new", "investigating", "confirmed", "in_progress", "resolved", "false_positive", "accepted_risk"}},
			"priority":   map[string]interface{}{"type": "string", "enum": []string{"p1", "p2", "p3", "p4"}},
			"sla_status": map[string]interface{}{"type": "string", "enum": []string{"ok", "breaching", "breached"}, "description": "Filter by SLA status"},
			"cve_id":     map[string]interface{}{"type": "string", "description": "Filter by specific CVE ID (e.g., CVE-2024-1234)"},
			"limit":      map[string]interface{}{"type": "integer", "default": 50},
		},
	}
}

func (t *ListCVEAlertsTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	query := `
		SELECT ca.id, ca.cve_id, ca.severity, ca.urgency_score, ca.status, ca.priority,
		       ca.sla_due_at, ca.sla_breached, ca.affected_images_count, ca.affected_assets_count,
		       ca.affected_packages_count, ca.production_assets_count, ca.detected_at,
		       cc.description, cc.cvss_v3_score, cc.epss_score, cc.exploit_available, cc.cisa_kev_listed
		FROM cve_alerts ca
		LEFT JOIN cve_cache cc ON ca.cve_cache_id = cc.id
		WHERE 1=1
	`
	args := []interface{}{}
	argIdx := 1

	if severity, ok := params["severity"].(string); ok && severity != "" {
		query += fmt.Sprintf(" AND ca.severity = $%d", argIdx)
		args = append(args, severity)
		argIdx++
	}
	if status, ok := params["status"].(string); ok && status != "" {
		query += fmt.Sprintf(" AND ca.status = $%d", argIdx)
		args = append(args, status)
		argIdx++
	}
	if priority, ok := params["priority"].(string); ok && priority != "" {
		query += fmt.Sprintf(" AND ca.priority = $%d", argIdx)
		args = append(args, priority)
		argIdx++
	}
	if cveID, ok := params["cve_id"].(string); ok && cveID != "" {
		query += fmt.Sprintf(" AND ca.cve_id = $%d", argIdx)
		args = append(args, cveID)
		argIdx++
	}
	if slaStatus, ok := params["sla_status"].(string); ok && slaStatus != "" {
		now := time.Now()
		switch slaStatus {
		case "breached":
			query += " AND ca.sla_breached = true"
		case "breaching":
			query += fmt.Sprintf(" AND ca.sla_breached = false AND ca.sla_due_at < $%d", argIdx)
			args = append(args, now.Add(24*time.Hour))
			argIdx++
		case "ok":
			query += fmt.Sprintf(" AND ca.sla_breached = false AND ca.sla_due_at >= $%d", argIdx)
			args = append(args, now.Add(24*time.Hour))
			argIdx++
		}
	}

	query += " ORDER BY ca.urgency_score DESC, ca.detected_at DESC"

	limit := 50
	if l, ok := params["limit"].(float64); ok {
		limit = int(l)
	}
	query += fmt.Sprintf(" LIMIT %d", limit)

	rows, err := t.db.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("query cve alerts failed: %w", err)
	}
	defer rows.Close()

	alerts := []map[string]interface{}{}
	for rows.Next() {
		var id uuid.UUID
		var cveID, severity, status string
		var urgencyScore, affectedImages, affectedAssets, affectedPackages, prodAssets int
		var priority *string
		var slaDueAt, detectedAt *time.Time
		var slaBreached bool
		var description *string
		var cvssScore, epssScore *float64
		var exploitAvailable, cisaKEV *bool

		err := rows.Scan(&id, &cveID, &severity, &urgencyScore, &status, &priority,
			&slaDueAt, &slaBreached, &affectedImages, &affectedAssets,
			&affectedPackages, &prodAssets, &detectedAt,
			&description, &cvssScore, &epssScore, &exploitAvailable, &cisaKEV)
		if err != nil {
			continue
		}

		alert := map[string]interface{}{
			"id":                      id.String(),
			"cve_id":                  cveID,
			"severity":                severity,
			"urgency_score":           urgencyScore,
			"status":                  status,
			"sla_breached":            slaBreached,
			"affected_images_count":   affectedImages,
			"affected_assets_count":   affectedAssets,
			"affected_packages_count": affectedPackages,
			"production_assets_count": prodAssets,
		}
		if priority != nil {
			alert["priority"] = *priority
		}
		if slaDueAt != nil {
			alert["sla_due_at"] = slaDueAt.Format(time.RFC3339)
		}
		if detectedAt != nil {
			alert["detected_at"] = detectedAt.Format(time.RFC3339)
		}
		if description != nil {
			alert["description"] = *description
		}
		if cvssScore != nil {
			alert["cvss_score"] = *cvssScore
		}
		if epssScore != nil {
			alert["epss_score"] = *epssScore
		}
		if exploitAvailable != nil && *exploitAvailable {
			alert["exploit_available"] = true
		}
		if cisaKEV != nil && *cisaKEV {
			alert["cisa_kev_listed"] = true
		}

		alerts = append(alerts, alert)
	}

	return map[string]interface{}{
		"alerts": alerts,
		"total":  len(alerts),
	}, nil
}

// GetCVEDetailsTool gets detailed information about a specific CVE.
type GetCVEDetailsTool struct {
	db *pgxpool.Pool
}

func (t *GetCVEDetailsTool) Name() string        { return "get_cve_details" }
func (t *GetCVEDetailsTool) Description() string { return "Get detailed information about a specific CVE including CVSS breakdown, references, and affected software" }
func (t *GetCVEDetailsTool) Risk() RiskLevel     { return RiskReadOnly }
func (t *GetCVEDetailsTool) Scope() Scope        { return ScopeOrganization }
func (t *GetCVEDetailsTool) Idempotent() bool    { return true }
func (t *GetCVEDetailsTool) RequiresApproval() bool { return false }
func (t *GetCVEDetailsTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"cve_id": map[string]interface{}{"type": "string", "description": "The CVE ID (e.g., CVE-2024-1234)"},
		},
		"required": []string{"cve_id"},
	}
}

func (t *GetCVEDetailsTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	cveID, ok := params["cve_id"].(string)
	if !ok || cveID == "" {
		return nil, fmt.Errorf("cve_id is required")
	}

	query := `
		SELECT id, cve_id, description, cvss_v3_score, cvss_v3_vector, cvss_v2_score,
		       epss_score, epss_percentile, exploit_available, exploit_last_seen,
		       cisa_kev_listed, cisa_kev_due_date, weaknesses, references,
		       affected_products, published_at, modified_at, source, source_url
		FROM cve_cache
		WHERE cve_id = $1
	`

	var id uuid.UUID
	var cveIDResult, source string
	var description, cvssV3Vector, sourceURL *string
	var cvssV3, cvssV2, epssScore, epssPercentile *float64
	var exploitAvailable, cisaKEVListed bool
	var exploitLastSeen, cisaKEVDueDate, publishedAt, modifiedAt *time.Time
	var weaknesses, references, affectedProducts []byte

	err := t.db.QueryRow(ctx, query, cveID).Scan(
		&id, &cveIDResult, &description, &cvssV3, &cvssV3Vector, &cvssV2,
		&epssScore, &epssPercentile, &exploitAvailable, &exploitLastSeen,
		&cisaKEVListed, &cisaKEVDueDate, &weaknesses, &references,
		&affectedProducts, &publishedAt, &modifiedAt, &source, &sourceURL,
	)
	if err != nil {
		return nil, fmt.Errorf("CVE not found: %s", cveID)
	}

	result := map[string]interface{}{
		"id":                id.String(),
		"cve_id":            cveIDResult,
		"source":            source,
		"exploit_available": exploitAvailable,
		"cisa_kev_listed":   cisaKEVListed,
	}

	if description != nil {
		result["description"] = *description
	}
	if cvssV3 != nil {
		result["cvss_v3_score"] = *cvssV3
	}
	if cvssV3Vector != nil {
		result["cvss_v3_vector"] = *cvssV3Vector
	}
	if cvssV2 != nil {
		result["cvss_v2_score"] = *cvssV2
	}
	if epssScore != nil {
		result["epss_score"] = *epssScore
		result["epss_percentile"] = epssPercentile
	}
	if exploitLastSeen != nil {
		result["exploit_last_seen"] = exploitLastSeen.Format(time.RFC3339)
	}
	if cisaKEVDueDate != nil {
		result["cisa_kev_due_date"] = cisaKEVDueDate.Format(time.RFC3339)
	}
	if publishedAt != nil {
		result["published_at"] = publishedAt.Format(time.RFC3339)
	}
	if modifiedAt != nil {
		result["modified_at"] = modifiedAt.Format(time.RFC3339)
	}
	if sourceURL != nil {
		result["source_url"] = *sourceURL
	}

	return result, nil
}

// =============================================================================
// Blast Radius Tools
// =============================================================================

// CalculateBlastRadiusTool calculates the impact of a CVE across the infrastructure.
type CalculateBlastRadiusTool struct {
	db     *pgxpool.Pool
	engine *blastradius.Engine
}

func (t *CalculateBlastRadiusTool) Name() string        { return "calculate_blast_radius" }
func (t *CalculateBlastRadiusTool) Description() string { return "Calculate the blast radius of a CVE - all affected packages, images, and assets including lineage propagation" }
func (t *CalculateBlastRadiusTool) Risk() RiskLevel     { return RiskReadOnly }
func (t *CalculateBlastRadiusTool) Scope() Scope        { return ScopeOrganization }
func (t *CalculateBlastRadiusTool) Idempotent() bool    { return true }
func (t *CalculateBlastRadiusTool) RequiresApproval() bool { return false }
func (t *CalculateBlastRadiusTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"cve_id":           map[string]interface{}{"type": "string", "description": "The CVE ID to calculate blast radius for"},
			"alert_id":         map[string]interface{}{"type": "string", "description": "The alert ID (alternative to cve_id)"},
			"include_lineage":  map[string]interface{}{"type": "boolean", "default": true, "description": "Include child images in lineage tree"},
			"production_only":  map[string]interface{}{"type": "boolean", "default": false, "description": "Only include production assets"},
		},
	}
}

func (t *CalculateBlastRadiusTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	cveID, _ := params["cve_id"].(string)
	alertIDStr, _ := params["alert_id"].(string)
	includeLineage := true
	if v, ok := params["include_lineage"].(bool); ok {
		includeLineage = v
	}
	productionOnly := false
	if v, ok := params["production_only"].(bool); ok {
		productionOnly = v
	}

	// Get the CVE cache ID from the alert if alert_id provided
	var cveCacheID uuid.UUID
	var orgID uuid.UUID

	if alertIDStr != "" {
		alertID, err := uuid.Parse(alertIDStr)
		if err != nil {
			return nil, fmt.Errorf("invalid alert_id: %w", err)
		}

		err = t.db.QueryRow(ctx,
			"SELECT org_id, cve_cache_id FROM cve_alerts WHERE id = $1",
			alertID,
		).Scan(&orgID, &cveCacheID)
		if err != nil {
			return nil, fmt.Errorf("alert not found: %w", err)
		}
	} else if cveID != "" {
		err := t.db.QueryRow(ctx,
			"SELECT id FROM cve_cache WHERE cve_id = $1",
			cveID,
		).Scan(&cveCacheID)
		if err != nil {
			return nil, fmt.Errorf("CVE not found: %s", cveID)
		}
		// For CVE-only query, we need an org_id - use the first matching alert
		t.db.QueryRow(ctx,
			"SELECT org_id FROM cve_alerts WHERE cve_id = $1 LIMIT 1",
			cveID,
		).Scan(&orgID)
	} else {
		return nil, fmt.Errorf("either cve_id or alert_id is required")
	}

	// Calculate blast radius using the engine
	// Note: includeLineage and productionOnly are handled by engine internally
	_ = includeLineage  // TODO: add support in engine
	_ = productionOnly  // TODO: add filtering support

	input := blastradius.CalculateInput{
		CVEID:      cveID,
		OrgID:      orgID,
	}

	result, err := t.engine.Calculate(ctx, input)
	if err != nil {
		return nil, fmt.Errorf("blast radius calculation failed: %w", err)
	}

	// Format response
	packages := make([]map[string]interface{}, 0, len(result.AffectedPackages))
	for _, pkg := range result.AffectedPackages {
		pkgMap := map[string]interface{}{
			"name":    pkg.PackageName,
			"version": pkg.PackageVersion,
			"type":    pkg.PackageType,
		}
		if pkg.FixedVersion != nil {
			pkgMap["fixed_version"] = *pkg.FixedVersion
		}
		packages = append(packages, pkgMap)
	}

	images := make([]map[string]interface{}, 0, len(result.AffectedImages))
	for _, img := range result.AffectedImages {
		images = append(images, map[string]interface{}{
			"id":            img.ImageID.String(),
			"family":        img.ImageFamily,
			"version":       img.ImageVersion,
			"lineage_depth": img.LineageDepth,
			"is_direct":     img.IsDirect,
		})
	}

	assets := make([]map[string]interface{}, 0, len(result.AffectedAssets))
	for _, asset := range result.AffectedAssets {
		assets = append(assets, map[string]interface{}{
			"id":            asset.AssetID.String(),
			"name":          asset.AssetName,
			"platform":      asset.Platform,
			"environment":   asset.Environment,
			"is_production": asset.IsProduction,
		})
	}

	return map[string]interface{}{
		"total_packages":         result.TotalPackages,
		"total_images":           result.TotalImages,
		"total_assets":           result.TotalAssets,
		"production_assets":      result.ProductionAssets,
		"affected_packages":      packages,
		"affected_images":        images,
		"affected_assets":        assets,
		"urgency_score":          result.UrgencyScore,
		"includes_lineage":       includeLineage,
	}, nil
}

// GetAlertBlastRadiusTool retrieves stored blast radius for an alert.
type GetAlertBlastRadiusTool struct {
	db *pgxpool.Pool
}

func (t *GetAlertBlastRadiusTool) Name() string        { return "get_alert_blast_radius" }
func (t *GetAlertBlastRadiusTool) Description() string { return "Get the stored blast radius details for a CVE alert including all affected items" }
func (t *GetAlertBlastRadiusTool) Risk() RiskLevel     { return RiskReadOnly }
func (t *GetAlertBlastRadiusTool) Scope() Scope        { return ScopeOrganization }
func (t *GetAlertBlastRadiusTool) Idempotent() bool    { return true }
func (t *GetAlertBlastRadiusTool) RequiresApproval() bool { return false }
func (t *GetAlertBlastRadiusTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"alert_id": map[string]interface{}{"type": "string", "description": "The CVE alert ID"},
		},
		"required": []string{"alert_id"},
	}
}

func (t *GetAlertBlastRadiusTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	alertIDStr, ok := params["alert_id"].(string)
	if !ok || alertIDStr == "" {
		return nil, fmt.Errorf("alert_id is required")
	}

	alertID, err := uuid.Parse(alertIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid alert_id: %w", err)
	}

	// Get affected items from cve_alert_affected_items table
	query := `
		SELECT item_type, item_id, item_name, additional_info, is_production, lineage_depth
		FROM cve_alert_affected_items
		WHERE alert_id = $1
		ORDER BY item_type, lineage_depth, item_name
	`

	rows, err := t.db.Query(ctx, query, alertID)
	if err != nil {
		return nil, fmt.Errorf("query affected items failed: %w", err)
	}
	defer rows.Close()

	packages := []map[string]interface{}{}
	images := []map[string]interface{}{}
	assets := []map[string]interface{}{}

	for rows.Next() {
		var itemType, itemName string
		var itemID uuid.UUID
		var additionalInfo []byte
		var isProduction bool
		var lineageDepth int

		if err := rows.Scan(&itemType, &itemID, &itemName, &additionalInfo, &isProduction, &lineageDepth); err != nil {
			continue
		}

		item := map[string]interface{}{
			"id":   itemID.String(),
			"name": itemName,
		}

		switch itemType {
		case "package":
			packages = append(packages, item)
		case "image":
			item["lineage_depth"] = lineageDepth
			images = append(images, item)
		case "asset":
			item["is_production"] = isProduction
			assets = append(assets, item)
		}
	}

	return map[string]interface{}{
		"alert_id":          alertIDStr,
		"packages":          packages,
		"images":            images,
		"assets":            assets,
		"total_packages":    len(packages),
		"total_images":      len(images),
		"total_assets":      len(assets),
		"production_assets": countProduction(assets),
	}, nil
}

func countProduction(assets []map[string]interface{}) int {
	count := 0
	for _, a := range assets {
		if prod, ok := a["is_production"].(bool); ok && prod {
			count++
		}
	}
	return count
}

// =============================================================================
// Patch Campaign Tools
// =============================================================================

// ListPatchCampaignsTool queries patch campaigns.
type ListPatchCampaignsTool struct {
	db *pgxpool.Pool
}

func (t *ListPatchCampaignsTool) Name() string        { return "list_patch_campaigns" }
func (t *ListPatchCampaignsTool) Description() string { return "List patch campaigns with filters (status, alert)" }
func (t *ListPatchCampaignsTool) Risk() RiskLevel     { return RiskReadOnly }
func (t *ListPatchCampaignsTool) Scope() Scope        { return ScopeOrganization }
func (t *ListPatchCampaignsTool) Idempotent() bool    { return true }
func (t *ListPatchCampaignsTool) RequiresApproval() bool { return false }
func (t *ListPatchCampaignsTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"status":   map[string]interface{}{"type": "string", "enum": []string{"draft", "pending_approval", "approved", "in_progress", "paused", "completed", "failed", "rolled_back", "cancelled"}},
			"alert_id": map[string]interface{}{"type": "string", "description": "Filter by CVE alert ID"},
			"limit":    map[string]interface{}{"type": "integer", "default": 50},
		},
	}
}

func (t *ListPatchCampaignsTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	query := `
		SELECT pc.id, pc.name, pc.description, pc.status, pc.strategy,
		       pc.total_assets, pc.patched_assets, pc.failed_assets,
		       pc.canary_percentage, pc.failure_threshold,
		       pc.created_at, pc.started_at, pc.completed_at,
		       ca.cve_id
		FROM patch_campaigns pc
		LEFT JOIN cve_alerts ca ON pc.cve_alert_id = ca.id
		WHERE 1=1
	`
	args := []interface{}{}
	argIdx := 1

	if status, ok := params["status"].(string); ok && status != "" {
		query += fmt.Sprintf(" AND pc.status = $%d", argIdx)
		args = append(args, status)
		argIdx++
	}
	if alertIDStr, ok := params["alert_id"].(string); ok && alertIDStr != "" {
		alertID, err := uuid.Parse(alertIDStr)
		if err == nil {
			query += fmt.Sprintf(" AND pc.cve_alert_id = $%d", argIdx)
			args = append(args, alertID)
			argIdx++
		}
	}

	query += " ORDER BY pc.created_at DESC"

	limit := 50
	if l, ok := params["limit"].(float64); ok {
		limit = int(l)
	}
	query += fmt.Sprintf(" LIMIT %d", limit)

	rows, err := t.db.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("query patch campaigns failed: %w", err)
	}
	defer rows.Close()

	campaigns := []map[string]interface{}{}
	for rows.Next() {
		var id uuid.UUID
		var name, status, strategy string
		var description, cveID *string
		var totalAssets, patchedAssets, failedAssets, canaryPct, failureThreshold int
		var createdAt time.Time
		var startedAt, completedAt *time.Time

		err := rows.Scan(&id, &name, &description, &status, &strategy,
			&totalAssets, &patchedAssets, &failedAssets,
			&canaryPct, &failureThreshold,
			&createdAt, &startedAt, &completedAt,
			&cveID)
		if err != nil {
			continue
		}

		campaign := map[string]interface{}{
			"id":                id.String(),
			"name":              name,
			"status":            status,
			"strategy":          strategy,
			"total_assets":      totalAssets,
			"patched_assets":    patchedAssets,
			"failed_assets":     failedAssets,
			"canary_percentage": canaryPct,
			"failure_threshold": failureThreshold,
			"created_at":        createdAt.Format(time.RFC3339),
		}
		if description != nil {
			campaign["description"] = *description
		}
		if cveID != nil {
			campaign["cve_id"] = *cveID
		}
		if startedAt != nil {
			campaign["started_at"] = startedAt.Format(time.RFC3339)
		}
		if completedAt != nil {
			campaign["completed_at"] = completedAt.Format(time.RFC3339)
		}

		campaigns = append(campaigns, campaign)
	}

	return map[string]interface{}{
		"campaigns": campaigns,
		"total":     len(campaigns),
	}, nil
}

// CreatePatchCampaignTool creates a new patch campaign.
type CreatePatchCampaignTool struct {
	db *pgxpool.Pool
}

func (t *CreatePatchCampaignTool) Name() string        { return "create_patch_campaign" }
func (t *CreatePatchCampaignTool) Description() string { return "Create a patch campaign to remediate a CVE across affected assets" }
func (t *CreatePatchCampaignTool) Risk() RiskLevel     { return RiskPlanOnly }
func (t *CreatePatchCampaignTool) Scope() Scope        { return ScopeOrganization }
func (t *CreatePatchCampaignTool) Idempotent() bool    { return false }
func (t *CreatePatchCampaignTool) RequiresApproval() bool { return true }
func (t *CreatePatchCampaignTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"alert_id":           map[string]interface{}{"type": "string", "description": "The CVE alert ID to remediate"},
			"name":               map[string]interface{}{"type": "string", "description": "Campaign name"},
			"description":        map[string]interface{}{"type": "string", "description": "Campaign description"},
			"strategy":           map[string]interface{}{"type": "string", "enum": []string{"canary", "rolling", "all_at_once", "blue_green"}, "default": "canary"},
			"canary_percentage":  map[string]interface{}{"type": "integer", "default": 5, "description": "Percentage of assets in canary phase"},
			"failure_threshold":  map[string]interface{}{"type": "integer", "default": 5, "description": "Failure percentage to trigger rollback"},
			"maintenance_window": map[string]interface{}{"type": "string", "description": "Preferred maintenance window (cron expression)"},
		},
		"required": []string{"alert_id", "name"},
	}
}

func (t *CreatePatchCampaignTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	alertIDStr, ok := params["alert_id"].(string)
	if !ok || alertIDStr == "" {
		return nil, fmt.Errorf("alert_id is required")
	}
	alertID, err := uuid.Parse(alertIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid alert_id: %w", err)
	}

	name, ok := params["name"].(string)
	if !ok || name == "" {
		return nil, fmt.Errorf("name is required")
	}

	description := ""
	if d, ok := params["description"].(string); ok {
		description = d
	}

	strategy := "canary"
	if s, ok := params["strategy"].(string); ok {
		strategy = s
	}

	canaryPct := 5
	if c, ok := params["canary_percentage"].(float64); ok {
		canaryPct = int(c)
	}

	failureThreshold := 5
	if f, ok := params["failure_threshold"].(float64); ok {
		failureThreshold = int(f)
	}

	// Get alert details
	var orgID uuid.UUID
	var affectedAssets int
	err = t.db.QueryRow(ctx,
		"SELECT org_id, affected_assets_count FROM cve_alerts WHERE id = $1",
		alertID,
	).Scan(&orgID, &affectedAssets)
	if err != nil {
		return nil, fmt.Errorf("alert not found: %w", err)
	}

	// Create campaign
	campaignID := uuid.New()
	query := `
		INSERT INTO patch_campaigns (
			id, org_id, cve_alert_id, name, description, status, strategy,
			total_assets, canary_percentage, failure_threshold, created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, 'draft', $6, $7, $8, $9, NOW(), NOW())
		RETURNING id
	`

	err = t.db.QueryRow(ctx, query,
		campaignID, orgID, alertID, name, description, strategy,
		affectedAssets, canaryPct, failureThreshold,
	).Scan(&campaignID)
	if err != nil {
		return nil, fmt.Errorf("create campaign failed: %w", err)
	}

	// Update alert with campaign reference
	_, err = t.db.Exec(ctx,
		"UPDATE cve_alerts SET patch_campaign_id = $1, status = 'in_progress', updated_at = NOW() WHERE id = $2",
		campaignID, alertID,
	)
	if err != nil {
		return nil, fmt.Errorf("update alert failed: %w", err)
	}

	return map[string]interface{}{
		"campaign_id":       campaignID.String(),
		"name":              name,
		"status":            "draft",
		"strategy":          strategy,
		"total_assets":      affectedAssets,
		"canary_percentage": canaryPct,
		"failure_threshold": failureThreshold,
		"message":           "Campaign created. Submit for approval to begin patching.",
	}, nil
}

// GetCampaignStatusTool gets detailed status of a patch campaign.
type GetCampaignStatusTool struct {
	db *pgxpool.Pool
}

func (t *GetCampaignStatusTool) Name() string        { return "get_campaign_status" }
func (t *GetCampaignStatusTool) Description() string { return "Get detailed status of a patch campaign including phase progress and asset status" }
func (t *GetCampaignStatusTool) Risk() RiskLevel     { return RiskReadOnly }
func (t *GetCampaignStatusTool) Scope() Scope        { return ScopeOrganization }
func (t *GetCampaignStatusTool) Idempotent() bool    { return true }
func (t *GetCampaignStatusTool) RequiresApproval() bool { return false }
func (t *GetCampaignStatusTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"campaign_id": map[string]interface{}{"type": "string", "description": "The patch campaign ID"},
		},
		"required": []string{"campaign_id"},
	}
}

func (t *GetCampaignStatusTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	campaignIDStr, ok := params["campaign_id"].(string)
	if !ok || campaignIDStr == "" {
		return nil, fmt.Errorf("campaign_id is required")
	}
	campaignID, err := uuid.Parse(campaignIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid campaign_id: %w", err)
	}

	// Get campaign details
	var name, status, strategy string
	var description *string
	var totalAssets, patchedAssets, failedAssets, canaryPct, failureThreshold int
	var createdAt time.Time
	var startedAt, completedAt *time.Time

	err = t.db.QueryRow(ctx, `
		SELECT name, description, status, strategy, total_assets, patched_assets,
		       failed_assets, canary_percentage, failure_threshold,
		       created_at, started_at, completed_at
		FROM patch_campaigns WHERE id = $1
	`, campaignID).Scan(&name, &description, &status, &strategy, &totalAssets, &patchedAssets,
		&failedAssets, &canaryPct, &failureThreshold, &createdAt, &startedAt, &completedAt)
	if err != nil {
		return nil, fmt.Errorf("campaign not found: %w", err)
	}

	// Get phases
	phaseRows, err := t.db.Query(ctx, `
		SELECT phase_number, phase_name, status, target_count, completed_count, failed_count,
		       started_at, completed_at
		FROM patch_campaign_phases WHERE campaign_id = $1 ORDER BY phase_number
	`, campaignID)
	if err != nil {
		return nil, fmt.Errorf("query phases failed: %w", err)
	}
	defer phaseRows.Close()

	phases := []map[string]interface{}{}
	for phaseRows.Next() {
		var phaseNum, targetCount, completedCount, failedCount int
		var phaseName, phaseStatus string
		var phaseStarted, phaseCompleted *time.Time

		if err := phaseRows.Scan(&phaseNum, &phaseName, &phaseStatus, &targetCount, &completedCount,
			&failedCount, &phaseStarted, &phaseCompleted); err != nil {
			continue
		}

		phase := map[string]interface{}{
			"phase_number":    phaseNum,
			"phase_name":      phaseName,
			"status":          phaseStatus,
			"target_count":    targetCount,
			"completed_count": completedCount,
			"failed_count":    failedCount,
		}
		if phaseStarted != nil {
			phase["started_at"] = phaseStarted.Format(time.RFC3339)
		}
		if phaseCompleted != nil {
			phase["completed_at"] = phaseCompleted.Format(time.RFC3339)
		}
		phases = append(phases, phase)
	}

	result := map[string]interface{}{
		"campaign_id":       campaignIDStr,
		"name":              name,
		"status":            status,
		"strategy":          strategy,
		"total_assets":      totalAssets,
		"patched_assets":    patchedAssets,
		"failed_assets":     failedAssets,
		"canary_percentage": canaryPct,
		"failure_threshold": failureThreshold,
		"phases":            phases,
		"created_at":        createdAt.Format(time.RFC3339),
	}

	if description != nil {
		result["description"] = *description
	}
	if startedAt != nil {
		result["started_at"] = startedAt.Format(time.RFC3339)
	}
	if completedAt != nil {
		result["completed_at"] = completedAt.Format(time.RFC3339)
	}

	// Calculate progress
	if totalAssets > 0 {
		result["progress_percentage"] = (patchedAssets * 100) / totalAssets
		result["failure_percentage"] = (failedAssets * 100) / totalAssets
	}

	return result, nil
}

// =============================================================================
// Urgency Scoring Tools
// =============================================================================

// CalculateUrgencyScoreTool calculates or recalculates urgency score for an alert.
type CalculateUrgencyScoreTool struct {
	db     *pgxpool.Pool
	scorer *blastradius.Scorer
}

func (t *CalculateUrgencyScoreTool) Name() string        { return "calculate_urgency_score" }
func (t *CalculateUrgencyScoreTool) Description() string { return "Calculate or recalculate the urgency score for a CVE alert based on CVSS, EPSS, exploit status, and blast radius" }
func (t *CalculateUrgencyScoreTool) Risk() RiskLevel     { return RiskReadOnly }
func (t *CalculateUrgencyScoreTool) Scope() Scope        { return ScopeOrganization }
func (t *CalculateUrgencyScoreTool) Idempotent() bool    { return true }
func (t *CalculateUrgencyScoreTool) RequiresApproval() bool { return false }
func (t *CalculateUrgencyScoreTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"alert_id": map[string]interface{}{"type": "string", "description": "The CVE alert ID"},
		},
		"required": []string{"alert_id"},
	}
}

func (t *CalculateUrgencyScoreTool) Execute(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	alertIDStr, ok := params["alert_id"].(string)
	if !ok || alertIDStr == "" {
		return nil, fmt.Errorf("alert_id is required")
	}
	alertID, err := uuid.Parse(alertIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid alert_id: %w", err)
	}

	// Get alert and CVE details
	var affectedAssets, prodAssets, totalFleetAssets int
	var cvssScore, epssScore *float64
	var exploitAvailable, cisaKEV bool

	err = t.db.QueryRow(ctx, `
		SELECT ca.affected_assets_count, ca.production_assets_count,
		       cc.cvss_v3_score, cc.epss_score, cc.exploit_available, cc.cisa_kev_listed,
		       (SELECT COUNT(*) FROM assets WHERE org_id = ca.org_id) as fleet_count
		FROM cve_alerts ca
		LEFT JOIN cve_cache cc ON ca.cve_cache_id = cc.id
		WHERE ca.id = $1
	`, alertID).Scan(&affectedAssets, &prodAssets, &cvssScore, &epssScore,
		&exploitAvailable, &cisaKEV, &totalFleetAssets)
	if err != nil {
		return nil, fmt.Errorf("alert not found: %w", err)
	}

	input := blastradius.ScoringInput{
		TotalAssets:      affectedAssets,
		ProductionAssets: prodAssets,
		TotalFleetAssets: totalFleetAssets,
		ExploitAvailable: exploitAvailable,
		CISAKEVListed:    cisaKEV,
	}
	if cvssScore != nil {
		input.CVSSScore = *cvssScore
	}
	if epssScore != nil {
		input.EPSSScore = *epssScore
	}

	result := t.scorer.Calculate(input)

	return map[string]interface{}{
		"alert_id":     alertIDStr,
		"urgency_score": result.UrgencyScore,
		"priority":     result.Priority,
		"sla_due_at":   result.SLADueAt.Format(time.RFC3339),
		"breakdown": map[string]interface{}{
			"cvss_contribution":       result.ScoreBreakdown.CVSSContribution,
			"exploit_contribution":    result.ScoreBreakdown.ExploitContribution,
			"cisa_kev_contribution":   result.ScoreBreakdown.CISAKEVContribution,
			"production_contribution": result.ScoreBreakdown.ProductionContribution,
			"fleet_contribution":      result.ScoreBreakdown.FleetContribution,
			"epss_contribution":       result.ScoreBreakdown.EPSSContribution,
			"raw_score":               result.ScoreBreakdown.RawScore,
		},
	}, nil
}

// =============================================================================
// Registration
// =============================================================================

// registerVulnerabilityTools registers vulnerability management tools.
func (r *Registry) registerVulnerabilityTools() {
	// Create shared components
	engine := blastradius.NewEngine(r.db, nil)
	scorer := blastradius.NewScorer(nil)

	// Query tools
	r.register(&ListCVEAlertsTool{db: r.db})
	r.register(&GetCVEDetailsTool{db: r.db})
	r.register(&GetAlertBlastRadiusTool{db: r.db})

	// Blast radius tools
	r.register(&CalculateBlastRadiusTool{db: r.db, engine: engine})

	// Patch campaign tools
	r.register(&ListPatchCampaignsTool{db: r.db})
	r.register(&CreatePatchCampaignTool{db: r.db})
	r.register(&GetCampaignStatusTool{db: r.db})

	// Scoring tools
	r.register(&CalculateUrgencyScoreTool{db: r.db, scorer: scorer})
}
