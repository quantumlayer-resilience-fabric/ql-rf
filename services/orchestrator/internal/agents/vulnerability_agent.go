// Package agents provides the specialist agent registry and implementations.
package agents

import (
	"context"
	"fmt"

	"github.com/quantumlayerhq/ql-rf/pkg/logger"
	"github.com/quantumlayerhq/ql-rf/services/orchestrator/internal/llm"
	"github.com/quantumlayerhq/ql-rf/services/orchestrator/internal/tools"
)

// VulnerabilityAgent handles CVE alert triage, blast radius analysis, and patch campaign planning.
type VulnerabilityAgent struct {
	BaseAgent
}

// NewVulnerabilityAgent creates a new vulnerability agent.
func NewVulnerabilityAgent(llmClient llm.Client, toolReg *tools.Registry, log *logger.Logger) *VulnerabilityAgent {
	return &VulnerabilityAgent{
		BaseAgent: BaseAgent{
			name:        "vulnerability_agent",
			description: "Handles CVE alert triage, blast radius analysis, and patch campaign planning",
			tasks:       []TaskType{TaskTypeVulnerabilityResponse},
			tools: []string{
				"list_cve_alerts",
				"get_cve_details",
				"calculate_blast_radius",
				"get_alert_blast_radius",
				"calculate_urgency_score",
				"list_patch_campaigns",
				"create_patch_campaign",
				"get_campaign_status",
				"query_assets",
			},
			llm:     llmClient,
			toolReg: toolReg,
			log:     log.WithComponent("vulnerability-agent"),
		},
	}
}

// Execute runs the vulnerability agent.
func (a *VulnerabilityAgent) Execute(ctx context.Context, task *TaskSpec) (*AgentResult, error) {
	a.log.Info("executing vulnerability agent", "task_id", task.ID, "goal", task.Goal)

	// Determine the sub-task based on user intent
	intent := task.UserIntent
	if intent == "" {
		intent = task.Goal
	}

	// Check for specific CVE or alert ID in context
	var alertID, cveID string
	if task.Context.Metadata != nil {
		if id, ok := task.Context.Metadata["alert_id"].(string); ok {
			alertID = id
		}
		if id, ok := task.Context.Metadata["cve_id"].(string); ok {
			cveID = id
		}
	}

	// Route to appropriate sub-handler
	if alertID != "" || cveID != "" {
		return a.handleSpecificCVE(ctx, task, alertID, cveID)
	}

	if contains(intent, "blast radius") || contains(intent, "impact") {
		return a.handleBlastRadiusAnalysis(ctx, task)
	}

	if contains(intent, "patch") || contains(intent, "remediate") || contains(intent, "campaign") {
		return a.handlePatchCampaign(ctx, task)
	}

	// Default: triage CVE alerts
	return a.handleCVETriage(ctx, task)
}

// handleCVETriage lists and prioritizes CVE alerts.
func (a *VulnerabilityAgent) handleCVETriage(ctx context.Context, task *TaskSpec) (*AgentResult, error) {
	a.log.Info("performing CVE triage", "org_id", task.OrgID)

	// Step 1: Get critical and high alerts
	criticalAlerts, err := a.executeTool(ctx, "list_cve_alerts", map[string]interface{}{
		"severity": "critical",
		"status":   "new",
		"limit":    20,
	})
	if err != nil {
		a.log.Warn("failed to list critical alerts", "error", err)
		criticalAlerts = map[string]interface{}{"alerts": []interface{}{}}
	}

	highAlerts, err := a.executeTool(ctx, "list_cve_alerts", map[string]interface{}{
		"severity": "high",
		"status":   "new",
		"limit":    20,
	})
	if err != nil {
		a.log.Warn("failed to list high alerts", "error", err)
		highAlerts = map[string]interface{}{"alerts": []interface{}{}}
	}

	// Step 2: Get SLA-breaching alerts
	breachingAlerts, err := a.executeTool(ctx, "list_cve_alerts", map[string]interface{}{
		"sla_status": "breaching",
		"limit":      10,
	})
	if err != nil {
		a.log.Warn("failed to list breaching alerts", "error", err)
		breachingAlerts = map[string]interface{}{"alerts": []interface{}{}}
	}

	// Step 3: Generate triage assessment using LLM
	assessment, tokensUsed, err := a.generateTriageAssessment(ctx, criticalAlerts, highAlerts, breachingAlerts, task)
	if err != nil {
		return nil, fmt.Errorf("failed to generate triage assessment: %w", err)
	}

	// Extract counts
	criticalCount := countAlerts(criticalAlerts)
	highCount := countAlerts(highAlerts)
	breachingCount := countAlerts(breachingAlerts)

	riskLevel := "low"
	if criticalCount > 0 || breachingCount > 0 {
		riskLevel = "critical"
	} else if highCount > 0 {
		riskLevel = "high"
	}

	return &AgentResult{
		TaskID:         task.ID,
		AgentName:      a.name,
		Status:         AgentStatusPendingApproval,
		Plan:           assessment,
		Summary:        fmt.Sprintf("CVE Triage: %d critical, %d high alerts. %d SLA breaching. Recommended actions generated.", criticalCount, highCount, breachingCount),
		AffectedAssets: 0, // Will be populated from alert data
		RiskLevel:      riskLevel,
		TokensUsed:     tokensUsed,
		Actions: []Action{
			{Type: "approve", Label: "Start Remediation", Description: "Create patch campaigns for recommended CVEs"},
			{Type: "modify", Label: "Modify Plan", Description: "Edit the remediation priorities"},
			{Type: "reject", Label: "Dismiss", Description: "Dismiss without action"},
		},
		Evidence: map[string]interface{}{
			"critical_alerts":  criticalAlerts,
			"high_alerts":      highAlerts,
			"breaching_alerts": breachingAlerts,
		},
	}, nil
}

// handleSpecificCVE analyzes a specific CVE alert.
func (a *VulnerabilityAgent) handleSpecificCVE(ctx context.Context, task *TaskSpec, alertID, cveID string) (*AgentResult, error) {
	a.log.Info("analyzing specific CVE", "alert_id", alertID, "cve_id", cveID)

	var cveDetails, blastRadius interface{}
	var err error

	// Get CVE details
	if cveID != "" {
		cveDetails, err = a.executeTool(ctx, "get_cve_details", map[string]interface{}{
			"cve_id": cveID,
		})
		if err != nil {
			a.log.Warn("failed to get CVE details", "error", err)
			cveDetails = map[string]interface{}{}
		}
	}

	// Calculate blast radius
	params := map[string]interface{}{
		"include_lineage": true,
	}
	if alertID != "" {
		params["alert_id"] = alertID
	} else if cveID != "" {
		params["cve_id"] = cveID
	}

	blastRadius, err = a.executeTool(ctx, "calculate_blast_radius", params)
	if err != nil {
		a.log.Warn("failed to calculate blast radius", "error", err)
		blastRadius = map[string]interface{}{}
	}

	// Generate detailed analysis
	analysis, tokensUsed, err := a.generateCVEAnalysis(ctx, cveDetails, blastRadius, task)
	if err != nil {
		return nil, fmt.Errorf("failed to generate CVE analysis: %w", err)
	}

	// Extract affected count
	affectedAssets := 0
	if br, ok := blastRadius.(map[string]interface{}); ok {
		if count, ok := br["total_assets"].(int); ok {
			affectedAssets = count
		} else if count, ok := br["total_assets"].(float64); ok {
			affectedAssets = int(count)
		}
	}

	riskLevel := "medium"
	if cd, ok := cveDetails.(map[string]interface{}); ok {
		if cvss, ok := cd["cvss_v3_score"].(float64); ok && cvss >= 9.0 {
			riskLevel = "critical"
		} else if cvss >= 7.0 {
			riskLevel = "high"
		}
		if kev, ok := cd["cisa_kev_listed"].(bool); ok && kev {
			riskLevel = "critical"
		}
	}

	return &AgentResult{
		TaskID:         task.ID,
		AgentName:      a.name,
		Status:         AgentStatusPendingApproval,
		Plan:           analysis,
		Summary:        fmt.Sprintf("CVE Analysis: %d assets affected. Risk: %s. Patch campaign recommended.", affectedAssets, riskLevel),
		AffectedAssets: affectedAssets,
		RiskLevel:      riskLevel,
		TokensUsed:     tokensUsed,
		Actions: []Action{
			{Type: "approve", Label: "Create Patch Campaign", Description: "Create a patch campaign to remediate this CVE"},
			{Type: "modify", Label: "Modify Analysis", Description: "Edit the analysis and recommendations"},
			{Type: "reject", Label: "Accept Risk", Description: "Accept the risk and close the alert"},
		},
		Evidence: map[string]interface{}{
			"cve_details":  cveDetails,
			"blast_radius": blastRadius,
		},
	}, nil
}

// handleBlastRadiusAnalysis performs blast radius analysis for CVEs.
func (a *VulnerabilityAgent) handleBlastRadiusAnalysis(ctx context.Context, task *TaskSpec) (*AgentResult, error) {
	a.log.Info("performing blast radius analysis")

	// Get alerts with highest blast radius
	alerts, err := a.executeTool(ctx, "list_cve_alerts", map[string]interface{}{
		"status": "new",
		"limit":  10,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list alerts: %w", err)
	}

	// Generate blast radius report
	report, tokensUsed, err := a.generateBlastRadiusReport(ctx, alerts, task)
	if err != nil {
		return nil, fmt.Errorf("failed to generate blast radius report: %w", err)
	}

	return &AgentResult{
		TaskID:         task.ID,
		AgentName:      a.name,
		Status:         AgentStatusPendingApproval,
		Plan:           report,
		Summary:        "Blast radius analysis completed. Review impact assessment and prioritization.",
		AffectedAssets: 0,
		RiskLevel:      "medium",
		TokensUsed:     tokensUsed,
		Actions: []Action{
			{Type: "approve", Label: "Accept Report", Description: "Accept the blast radius report"},
			{Type: "modify", Label: "Refine Analysis", Description: "Request additional analysis"},
		},
		Evidence: map[string]interface{}{
			"alerts": alerts,
		},
	}, nil
}

// handlePatchCampaign creates a patch campaign for remediation.
func (a *VulnerabilityAgent) handlePatchCampaign(ctx context.Context, task *TaskSpec) (*AgentResult, error) {
	a.log.Info("creating patch campaign")

	// Get the alert ID from context
	alertID := ""
	if task.Context.Metadata != nil {
		if id, ok := task.Context.Metadata["alert_id"].(string); ok {
			alertID = id
		}
	}

	if alertID == "" {
		// Get the highest priority unpatched alert
		alerts, err := a.executeTool(ctx, "list_cve_alerts", map[string]interface{}{
			"priority": "p1",
			"status":   "new",
			"limit":    1,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to find alerts: %w", err)
		}

		// Extract first alert ID
		if am, ok := alerts.(map[string]interface{}); ok {
			if alertList, ok := am["alerts"].([]interface{}); ok && len(alertList) > 0 {
				if alert, ok := alertList[0].(map[string]interface{}); ok {
					if id, ok := alert["id"].(string); ok {
						alertID = id
					}
				}
			}
		}
	}

	if alertID == "" {
		return &AgentResult{
			TaskID:    task.ID,
			AgentName: a.name,
			Status:    AgentStatusCompleted,
			Summary:   "No CVE alerts found that require patching.",
			RiskLevel: "low",
		}, nil
	}

	// Generate campaign plan using LLM
	campaignPlan, tokensUsed, err := a.generateCampaignPlan(ctx, alertID, task)
	if err != nil {
		return nil, fmt.Errorf("failed to generate campaign plan: %w", err)
	}

	return &AgentResult{
		TaskID:         task.ID,
		AgentName:      a.name,
		Status:         AgentStatusPendingApproval,
		Plan:           campaignPlan,
		Summary:        "Patch campaign plan generated. Review and approve to begin remediation.",
		AffectedAssets: 0,
		RiskLevel:      "medium",
		TokensUsed:     tokensUsed,
		Actions: []Action{
			{Type: "approve", Label: "Create Campaign", Description: "Create the patch campaign"},
			{Type: "modify", Label: "Modify Plan", Description: "Adjust the campaign parameters"},
			{Type: "reject", Label: "Cancel", Description: "Do not create a campaign"},
		},
		Evidence: map[string]interface{}{
			"alert_id": alertID,
		},
	}, nil
}

// =============================================================================
// LLM Generation Methods
// =============================================================================

func (a *VulnerabilityAgent) generateTriageAssessment(ctx context.Context, critical, high, breaching interface{}, task *TaskSpec) (interface{}, int, error) {
	prompt := fmt.Sprintf(`You are the QL-RF Vulnerability Agent. Perform a CVE triage assessment.

## User Request
%s

## Environment
%s

## Critical Alerts (P1)
%v

## High Alerts (P2)
%v

## SLA-Breaching Alerts
%v

## Your Task
Analyze these CVE alerts and provide:
1. Executive summary of vulnerability exposure
2. Prioritized list of CVEs to address immediately
3. Recommended remediation approach for each
4. Resource requirements for patching

Output ONLY valid JSON:
{
  "summary": "Brief vulnerability assessment summary",
  "total_critical": 0,
  "total_high": 0,
  "total_affected_assets": 0,
  "exposure_score": 75,
  "immediate_actions": [
    {
      "cve_id": "CVE-2024-XXXX",
      "severity": "critical",
      "urgency_score": 95,
      "affected_assets": 10,
      "production_impact": true,
      "reason": "Why this needs immediate attention",
      "recommended_action": "Create patch campaign",
      "remediation_approach": "Detailed remediation steps",
      "estimated_effort": "2 hours"
    }
  ],
  "scheduled_patches": [
    {
      "cve_id": "CVE-2024-YYYY",
      "severity": "high",
      "urgency_score": 65,
      "affected_assets": 5,
      "recommended_window": "Next maintenance window",
      "reason": "Why this can wait"
    }
  ],
  "risk_acceptance_candidates": [
    {
      "cve_id": "CVE-2024-ZZZZ",
      "reason": "Why this may be acceptable risk"
    }
  ],
  "resource_requirements": {
    "estimated_hours": 8,
    "teams_required": ["security", "platform"],
    "maintenance_windows_needed": 2
  }
}`, task.UserIntent, task.Environment, critical, high, breaching)

	resp, err := a.llm.Complete(ctx, &llm.CompletionRequest{
		SystemPrompt: "You are a security expert specializing in vulnerability management. Provide actionable CVE triage assessments. Output ONLY valid JSON.",
		Messages: []llm.Message{
			{Role: "user", Content: prompt},
		},
	})
	if err != nil {
		return nil, 0, fmt.Errorf("LLM completion failed: %w", err)
	}

	var assessment map[string]interface{}
	content := resp.Content

	if startIdx := findJSONStart(content); startIdx >= 0 {
		if endIdx := findJSONEnd(content, startIdx); endIdx > startIdx {
			content = content[startIdx : endIdx+1]
		}
	}

	if err := parseJSON(content, &assessment); err != nil {
		a.log.Warn("failed to parse LLM response", "error", err)
		assessment = map[string]interface{}{
			"summary":          "CVE triage completed. Manual review required.",
			"immediate_actions": []interface{}{},
		}
	}

	return assessment, resp.Usage.TotalTokens, nil
}

func (a *VulnerabilityAgent) generateCVEAnalysis(ctx context.Context, cveDetails, blastRadius interface{}, task *TaskSpec) (interface{}, int, error) {
	prompt := fmt.Sprintf(`You are the QL-RF Vulnerability Agent. Analyze this specific CVE.

## User Request
%s

## CVE Details
%v

## Blast Radius
%v

## Your Task
Provide a comprehensive CVE analysis including:
1. Vulnerability description and technical details
2. Blast radius impact assessment
3. Exploitation likelihood assessment
4. Recommended remediation steps
5. Patch campaign parameters

Output ONLY valid JSON:
{
  "cve_analysis": {
    "cve_id": "CVE-2024-XXXX",
    "title": "Vulnerability title",
    "severity": "critical",
    "cvss_score": 9.8,
    "description": "Detailed description",
    "attack_vector": "Network exploitable",
    "exploitation_status": "Actively exploited"
  },
  "blast_radius_assessment": {
    "total_assets": 50,
    "production_assets": 10,
    "development_assets": 40,
    "total_images": 5,
    "affected_platforms": ["aws", "gcp"],
    "lineage_impact": "Parent image affects 3 child images"
  },
  "risk_assessment": {
    "overall_risk": "critical",
    "urgency_score": 95,
    "exploitation_likelihood": "high",
    "business_impact": "Service disruption possible",
    "data_exposure_risk": "Confidential data at risk"
  },
  "remediation_plan": {
    "recommended_action": "Emergency patch",
    "patch_strategy": "canary",
    "canary_percentage": 5,
    "estimated_duration": "4 hours",
    "rollback_plan": "Automatic rollback on failure",
    "steps": [
      "Step 1: Create patch campaign",
      "Step 2: Deploy to canary (5 percent)",
      "Step 3: Monitor for 30 minutes",
      "Step 4: Progressive rollout"
    ]
  },
  "campaign_parameters": {
    "name": "CVE-2024-XXXX Emergency Patch",
    "strategy": "canary",
    "canary_percentage": 5,
    "failure_threshold": 5,
    "health_check_interval": "5m",
    "maintenance_window": "ASAP"
  }
}`, task.UserIntent, cveDetails, blastRadius)

	resp, err := a.llm.Complete(ctx, &llm.CompletionRequest{
		SystemPrompt: "You are a security expert analyzing CVE vulnerabilities. Provide detailed technical analysis and actionable remediation plans. Output ONLY valid JSON.",
		Messages: []llm.Message{
			{Role: "user", Content: prompt},
		},
	})
	if err != nil {
		return nil, 0, fmt.Errorf("LLM completion failed: %w", err)
	}

	var analysis map[string]interface{}
	content := resp.Content

	if startIdx := findJSONStart(content); startIdx >= 0 {
		if endIdx := findJSONEnd(content, startIdx); endIdx > startIdx {
			content = content[startIdx : endIdx+1]
		}
	}

	if err := parseJSON(content, &analysis); err != nil {
		a.log.Warn("failed to parse LLM response", "error", err)
		analysis = map[string]interface{}{
			"cve_analysis": map[string]interface{}{
				"description": "CVE analysis completed. Manual review required.",
			},
		}
	}

	return analysis, resp.Usage.TotalTokens, nil
}

func (a *VulnerabilityAgent) generateBlastRadiusReport(ctx context.Context, alerts interface{}, task *TaskSpec) (interface{}, int, error) {
	prompt := fmt.Sprintf(`You are the QL-RF Vulnerability Agent. Generate a blast radius report.

## Alerts to Analyze
%v

## Your Task
Analyze the blast radius across all CVE alerts and provide:
1. Summary of total infrastructure exposure
2. Most impactful CVEs by blast radius
3. Asset concentration analysis
4. Recommended prioritization

Output ONLY valid JSON:
{
  "summary": "Overall blast radius assessment",
  "total_exposure": {
    "total_cves": 10,
    "total_affected_assets": 100,
    "production_assets": 25,
    "unique_images": 15,
    "platforms_affected": ["aws", "gcp", "k8s"]
  },
  "highest_impact_cves": [
    {
      "cve_id": "CVE-2024-XXXX",
      "severity": "critical",
      "affected_assets": 50,
      "production_impact": true,
      "blast_radius_score": 95
    }
  ],
  "asset_concentration": {
    "most_affected_platform": "aws",
    "most_affected_region": "us-east-1",
    "highest_risk_image": "base-ubuntu-22.04"
  },
  "prioritization": [
    {
      "priority": 1,
      "cve_id": "CVE-2024-XXXX",
      "reason": "Highest blast radius with production impact"
    }
  ]
}`, alerts)

	resp, err := a.llm.Complete(ctx, &llm.CompletionRequest{
		SystemPrompt: "You are a security expert analyzing vulnerability blast radius. Output ONLY valid JSON.",
		Messages: []llm.Message{
			{Role: "user", Content: prompt},
		},
	})
	if err != nil {
		return nil, 0, fmt.Errorf("LLM completion failed: %w", err)
	}

	var report map[string]interface{}
	content := resp.Content

	if startIdx := findJSONStart(content); startIdx >= 0 {
		if endIdx := findJSONEnd(content, startIdx); endIdx > startIdx {
			content = content[startIdx : endIdx+1]
		}
	}

	if err := parseJSON(content, &report); err != nil {
		a.log.Warn("failed to parse LLM response", "error", err)
		report = map[string]interface{}{
			"summary": "Blast radius report completed. Manual review required.",
		}
	}

	return report, resp.Usage.TotalTokens, nil
}

func (a *VulnerabilityAgent) generateCampaignPlan(ctx context.Context, alertID string, task *TaskSpec) (interface{}, int, error) {
	// Get alert details
	alerts, _ := a.executeTool(ctx, "list_cve_alerts", map[string]interface{}{
		"limit": 1,
	})

	prompt := fmt.Sprintf(`You are the QL-RF Vulnerability Agent. Generate a patch campaign plan.

## Alert ID
%s

## Alert Context
%v

## User Request
%s

## Your Task
Create a comprehensive patch campaign plan:
1. Campaign name and description
2. Deployment strategy (canary, rolling, blue-green)
3. Phase breakdown with target percentages
4. Success criteria and health checks
5. Rollback triggers

Output ONLY valid JSON:
{
  "campaign_plan": {
    "name": "CVE-XXXX Emergency Patch Campaign",
    "description": "Patch campaign to remediate CVE-XXXX across affected assets",
    "alert_id": "%s",
    "strategy": "canary",
    "total_estimated_duration": "4 hours"
  },
  "phases": [
    {
      "phase_number": 1,
      "phase_name": "canary",
      "target_percentage": 5,
      "estimated_duration": "30 minutes",
      "health_check_wait": "15 minutes",
      "success_criteria": "No errors, all health checks passing"
    },
    {
      "phase_number": 2,
      "phase_name": "wave_1",
      "target_percentage": 25,
      "estimated_duration": "45 minutes",
      "health_check_wait": "15 minutes"
    },
    {
      "phase_number": 3,
      "phase_name": "wave_2",
      "target_percentage": 50,
      "estimated_duration": "45 minutes",
      "health_check_wait": "15 minutes"
    },
    {
      "phase_number": 4,
      "phase_name": "wave_3",
      "target_percentage": 100,
      "estimated_duration": "60 minutes"
    }
  ],
  "rollback_configuration": {
    "failure_threshold": 5,
    "automatic_rollback": true,
    "rollback_triggers": [
      "Health check failure rate > 5%%",
      "Error rate spike > 10%%",
      "Manual intervention"
    ]
  },
  "health_checks": [
    {
      "name": "application_health",
      "type": "http",
      "endpoint": "/health",
      "expected_status": 200,
      "interval": "30s"
    },
    {
      "name": "cpu_utilization",
      "type": "metric",
      "threshold": "< 80%%"
    }
  ],
  "notifications": {
    "on_phase_complete": true,
    "on_failure": true,
    "on_rollback": true,
    "channels": ["slack", "email"]
  },
  "parameters_for_creation": {
    "alert_id": "%s",
    "name": "CVE-XXXX Emergency Patch Campaign",
    "strategy": "canary",
    "canary_percentage": 5,
    "failure_threshold": 5
  }
}`, alertID, alerts, task.UserIntent, alertID, alertID)

	resp, err := a.llm.Complete(ctx, &llm.CompletionRequest{
		SystemPrompt: "You are a DevOps expert creating patch deployment campaigns. Output ONLY valid JSON.",
		Messages: []llm.Message{
			{Role: "user", Content: prompt},
		},
	})
	if err != nil {
		return nil, 0, fmt.Errorf("LLM completion failed: %w", err)
	}

	var plan map[string]interface{}
	content := resp.Content

	if startIdx := findJSONStart(content); startIdx >= 0 {
		if endIdx := findJSONEnd(content, startIdx); endIdx > startIdx {
			content = content[startIdx : endIdx+1]
		}
	}

	if err := parseJSON(content, &plan); err != nil {
		a.log.Warn("failed to parse LLM response", "error", err)
		plan = map[string]interface{}{
			"campaign_plan": map[string]interface{}{
				"name":     "Patch Campaign",
				"strategy": "canary",
				"alert_id": alertID,
			},
		}
	}

	return plan, resp.Usage.TotalTokens, nil
}

// =============================================================================
// Helper Functions
// =============================================================================

func countAlerts(alerts interface{}) int {
	if m, ok := alerts.(map[string]interface{}); ok {
		if total, ok := m["total"].(int); ok {
			return total
		}
		if total, ok := m["total"].(float64); ok {
			return int(total)
		}
		if alertList, ok := m["alerts"].([]interface{}); ok {
			return len(alertList)
		}
	}
	return 0
}
