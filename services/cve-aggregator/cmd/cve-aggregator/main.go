// Package main is the entry point for the CVE Aggregator service.
// The CVE Aggregator polls multiple vulnerability data sources (NVD, OSV, CISA KEV, GitHub)
// and aggregates them into a unified CVE cache for the QL-RF platform.
package main

import (
	"context"
	"log/slog"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/quantumlayerhq/ql-rf/pkg/config"
	"github.com/quantumlayerhq/ql-rf/pkg/database"
	"github.com/quantumlayerhq/ql-rf/services/cve-aggregator/internal/feeds"
)

func main() {
	// Initialize structured logging
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}))
	slog.SetDefault(logger)

	logger.Info("starting CVE Aggregator service")

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		logger.Error("failed to load configuration", "error", err)
		os.Exit(1)
	}

	// Initialize database connection
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	db, err := database.New(ctx, cfg.Database)
	cancel()
	if err != nil {
		logger.Error("failed to connect to database", "error", err)
		os.Exit(1)
	}
	defer db.Close()

	// Verify database connection
	ctx, cancel = context.WithTimeout(context.Background(), 10*time.Second)
	if err := db.Health(ctx); err != nil {
		cancel()
		logger.Error("database health check failed", "error", err)
		os.Exit(1)
	}
	cancel()
	logger.Info("connected to database")

	// TODO: Use db for CVE storage
	_ = db

	// Initialize feed manager
	feedManager := feeds.NewFeedManager()

	// Register feeds
	nvdAPIKey := os.Getenv("RF_NVD_API_KEY")
	nvdFeed := feeds.NewNVDFeed(nvdAPIKey, logger)
	feedManager.RegisterFeed(nvdFeed, feeds.FeedConfig{
		Enabled:      true,
		PollInterval: 15 * time.Minute,
		RateLimit:    30,
		BatchSize:    100,
		Timeout:      60 * time.Second,
		RetryCount:   3,
		RetryBackoff: 5 * time.Second,
	})

	cisaFeed := feeds.NewCISAKEVFeed(logger)
	feedManager.RegisterFeed(cisaFeed, feeds.FeedConfig{
		Enabled:      true,
		PollInterval: 60 * time.Minute,
		RateLimit:    10,
		BatchSize:    1000,
		Timeout:      60 * time.Second,
		RetryCount:   3,
		RetryBackoff: 5 * time.Second,
	})

	osvFeed := feeds.NewOSVFeed(logger)
	feedManager.RegisterFeed(osvFeed, feeds.FeedConfig{
		Enabled:      true,
		PollInterval: 30 * time.Minute,
		RateLimit:    60,
		BatchSize:    100,
		Timeout:      60 * time.Second,
		RetryCount:   3,
		RetryBackoff: 5 * time.Second,
	})

	// Register GitHub Advisory feed
	githubToken := os.Getenv("RF_GITHUB_TOKEN")
	if githubToken != "" {
		githubFeed := feeds.NewGitHubAdvisoryFeed(githubToken, logger)
		feedManager.RegisterFeed(githubFeed, feeds.FeedConfig{
			Enabled:      true,
			PollInterval: 30 * time.Minute,
			RateLimit:    60,
			BatchSize:    100,
			Timeout:      60 * time.Second,
			RetryCount:   3,
			RetryBackoff: 5 * time.Second,
		})
	} else {
		logger.Warn("RF_GITHUB_TOKEN not set; GitHub Advisory feed disabled")
	}

	logger.Info("registered CVE feeds",
		"enabled_feeds", len(feedManager.GetEnabledFeeds()))

	// Health check all feeds
	ctx, cancel = context.WithTimeout(context.Background(), 30*time.Second)
	for _, feed := range feedManager.GetEnabledFeeds() {
		if err := feed.HealthCheck(ctx); err != nil {
			logger.Warn("feed health check failed",
				"feed", feed.Name(),
				"error", err)
		} else {
			logger.Info("feed health check passed", "feed", feed.Name())
		}
	}
	cancel()

	// Set up graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	// Start the polling loop
	logger.Info("starting CVE polling loop")

	// Initial poll
	pollFeeds(ctx, feedManager, logger)

	// Create ticker for periodic polling
	ticker := time.NewTicker(15 * time.Minute)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			logger.Info("shutting down CVE Aggregator")
			return
		case <-ticker.C:
			pollFeeds(ctx, feedManager, logger)
		}
	}
}

// pollFeeds polls all enabled feeds for new CVEs.
func pollFeeds(ctx context.Context, manager *feeds.FeedManager, logger *slog.Logger) {
	logger.Info("polling CVE feeds")

	for _, feed := range manager.GetEnabledFeeds() {
		config, ok := manager.GetConfig(feed.Name())
		if !ok {
			continue
		}

		feedCtx, cancel := context.WithTimeout(ctx, config.Timeout)

		startTime := time.Now()
		cves, err := feed.FetchCVEs(feedCtx, time.Now().Add(-24*time.Hour))
		duration := time.Since(startTime)
		cancel()

		if err != nil {
			logger.Error("failed to fetch CVEs from feed",
				"feed", feed.Name(),
				"error", err,
				"duration", duration)
			continue
		}

		logger.Info("fetched CVEs from feed",
			"feed", feed.Name(),
			"count", len(cves),
			"duration", duration)

		// TODO: Store CVEs in database
		// TODO: Match CVEs against SBOM packages
		// TODO: Create/update alerts for affected organizations
	}
}
