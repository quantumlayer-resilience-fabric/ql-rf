package matcher

import (
	"encoding/json"
	"log/slog"
	"os"
	"testing"

	"github.com/google/uuid"
	"github.com/quantumlayerhq/ql-rf/pkg/models"
)

func testLogger() *slog.Logger {
	return slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
}

// =============================================================================
// Matcher Unit Tests
// =============================================================================

func TestMatcher_NewMatcher(t *testing.T) {
	// Note: We can't test with real DB connection in unit tests
	// This just verifies the constructor works
	m := NewMatcher(nil, testLogger())
	if m == nil {
		t.Error("expected non-nil matcher")
	}
	if m.logger == nil {
		t.Error("expected logger to be set")
	}
}

// =============================================================================
// CPE Parsing Tests
// =============================================================================

func TestMatcher_ParseCPE_ValidCPE23(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	tests := []struct {
		name     string
		cpe      string
		expected AffectedConfig
	}{
		{
			name: "standard CPE 2.3",
			cpe:  "cpe:2.3:a:apache:log4j:2.14.1:*:*:*:*:*:*:*",
			expected: AffectedConfig{
				Vendor:  "apache",
				Product: "log4j",
				Version: "2.14.1",
			},
		},
		{
			name: "CPE with wildcard version",
			cpe:  "cpe:2.3:a:microsoft:windows:*:*:*:*:*:*:*:*",
			expected: AffectedConfig{
				Vendor:  "microsoft",
				Product: "windows",
				Version: "",
			},
		},
		{
			name: "CPE with dash version",
			cpe:  "cpe:2.3:a:openssl:openssl:-:*:*:*:*:*:*:*",
			expected: AffectedConfig{
				Vendor:  "openssl",
				Product: "openssl",
				Version: "",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			config := m.parseCPE(tt.cpe)
			if config.Vendor != tt.expected.Vendor {
				t.Errorf("expected vendor '%s', got '%s'", tt.expected.Vendor, config.Vendor)
			}
			if config.Product != tt.expected.Product {
				t.Errorf("expected product '%s', got '%s'", tt.expected.Product, config.Product)
			}
			if config.Version != tt.expected.Version {
				t.Errorf("expected version '%s', got '%s'", tt.expected.Version, config.Version)
			}
		})
	}
}

func TestMatcher_ParseCPE_InvalidCPE(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	tests := []struct {
		name string
		cpe  string
	}{
		{name: "empty string", cpe: ""},
		{name: "too short", cpe: "cpe:2.3:a"},
		{name: "not a CPE", cpe: "not-a-cpe-string"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			config := m.parseCPE(tt.cpe)
			if config.Product != "" {
				t.Errorf("expected empty product for invalid CPE, got '%s'", config.Product)
			}
		})
	}
}

// =============================================================================
// OSV Affected Parsing Tests
// =============================================================================

func TestMatcher_ParseOSVAffected(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	aff := map[string]interface{}{
		"package": map[string]interface{}{
			"name":      "lodash",
			"ecosystem": "npm",
			"purl":      "pkg:npm/lodash@4.17.0",
		},
	}

	config := m.parseOSVAffected(aff)

	if config.Product != "lodash" {
		t.Errorf("expected product 'lodash', got '%s'", config.Product)
	}
	if config.Ecosystem != "npm" {
		t.Errorf("expected ecosystem 'npm', got '%s'", config.Ecosystem)
	}
	if config.PURL != "pkg:npm/lodash@4.17.0" {
		t.Errorf("expected PURL 'pkg:npm/lodash@4.17.0', got '%s'", config.PURL)
	}
}

func TestMatcher_ParseOSVAffected_EmptyPackage(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	aff := map[string]interface{}{}
	config := m.parseOSVAffected(aff)

	if config.Product != "" {
		t.Errorf("expected empty product for missing package, got '%s'", config.Product)
	}
}

// =============================================================================
// Affected Config Extraction Tests
// =============================================================================

func TestMatcher_ExtractAffectedConfigs_FromCPEPatterns(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	cpes := []string{
		"cpe:2.3:a:apache:log4j:2.14.1:*:*:*:*:*:*:*",
		"cpe:2.3:a:apache:log4j:2.15.0:*:*:*:*:*:*:*",
	}
	cpeJSON, _ := json.Marshal(cpes)

	cve := &models.CVECache{
		CVEID:              "CVE-2021-44228",
		AffectedCPEPatterns: cpeJSON,
	}

	configs := m.extractAffectedConfigs(cve)

	if len(configs) != 2 {
		t.Fatalf("expected 2 configs, got %d", len(configs))
	}

	if configs[0].Product != "log4j" {
		t.Errorf("expected product 'log4j', got '%s'", configs[0].Product)
	}
}

func TestMatcher_ExtractAffectedConfigs_FromRawData_OSV(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	rawData := map[string]interface{}{
		"affected": []interface{}{
			map[string]interface{}{
				"package": map[string]interface{}{
					"name":      "axios",
					"ecosystem": "npm",
				},
			},
		},
	}
	rawJSON, _ := json.Marshal(rawData)

	cve := &models.CVECache{
		CVEID:   "GHSA-xxxx-yyyy-zzzz",
		RawData: rawJSON,
	}

	configs := m.extractAffectedConfigs(cve)

	if len(configs) != 1 {
		t.Fatalf("expected 1 config from OSV format, got %d", len(configs))
	}

	if configs[0].Product != "axios" {
		t.Errorf("expected product 'axios', got '%s'", configs[0].Product)
	}
}

// =============================================================================
// Match Deduplication Tests
// =============================================================================

func TestMatcher_DeduplicateMatches(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	pkgID := uuid.New()
	matches := []PackageMatch{
		{
			SBOMPackageID: pkgID,
			MatchMethod:   "name_version",
			MatchScore:    0.5,
		},
		{
			SBOMPackageID: pkgID,
			MatchMethod:   "cpe",
			MatchScore:    0.95,
		},
		{
			SBOMPackageID: pkgID,
			MatchMethod:   "purl",
			MatchScore:    0.90,
		},
	}

	deduped := m.deduplicateMatches(matches)

	if len(deduped) != 1 {
		t.Fatalf("expected 1 deduplicated match, got %d", len(deduped))
	}

	// Should keep highest confidence match
	if deduped[0].MatchScore != 0.95 {
		t.Errorf("expected match score 0.95, got %f", deduped[0].MatchScore)
	}
	if deduped[0].MatchMethod != "cpe" {
		t.Errorf("expected match method 'cpe', got '%s'", deduped[0].MatchMethod)
	}
}

func TestMatcher_DeduplicateMatches_MultiplePkgs(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	pkgID1 := uuid.New()
	pkgID2 := uuid.New()

	matches := []PackageMatch{
		{SBOMPackageID: pkgID1, MatchScore: 0.8},
		{SBOMPackageID: pkgID2, MatchScore: 0.9},
		{SBOMPackageID: pkgID1, MatchScore: 0.7},
	}

	deduped := m.deduplicateMatches(matches)

	if len(deduped) != 2 {
		t.Fatalf("expected 2 deduplicated matches, got %d", len(deduped))
	}
}

// =============================================================================
// NVD Configuration Parsing Tests
// =============================================================================

func TestMatcher_ParseNVDConfiguration(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	cfg := map[string]interface{}{
		"nodes": []interface{}{
			map[string]interface{}{
				"cpeMatch": []interface{}{
					map[string]interface{}{
						"criteria": "cpe:2.3:a:vendor:product:1.0:*:*:*:*:*:*:*",
					},
				},
			},
		},
	}

	configs := m.parseNVDConfiguration(cfg)

	if len(configs) != 1 {
		t.Fatalf("expected 1 config from NVD format, got %d", len(configs))
	}

	if configs[0].Product != "product" {
		t.Errorf("expected product 'product', got '%s'", configs[0].Product)
	}
	if configs[0].Vendor != "vendor" {
		t.Errorf("expected vendor 'vendor', got '%s'", configs[0].Vendor)
	}
}

func TestMatcher_ParseNVDNode_EmptyNode(t *testing.T) {
	m := &Matcher{logger: testLogger()}

	configs := m.parseNVDNode(map[string]interface{}{})
	if len(configs) != 0 {
		t.Errorf("expected 0 configs for empty node, got %d", len(configs))
	}
}

// =============================================================================
// Match Result Tests
// =============================================================================

func TestMatchResult_Structure(t *testing.T) {
	result := &MatchResult{
		CVEID:           "CVE-2024-1234",
		Matches:         []PackageMatch{},
		AffectedOrgIDs:  []uuid.UUID{},
		AffectedSBOMIDs: []uuid.UUID{},
	}

	if result.CVEID != "CVE-2024-1234" {
		t.Errorf("expected CVE ID 'CVE-2024-1234', got '%s'", result.CVEID)
	}
}

// =============================================================================
// Package Match Tests
// =============================================================================

func TestPackageMatch_Structure(t *testing.T) {
	match := PackageMatch{
		CVECacheID:    uuid.New(),
		CVEID:         "CVE-2024-5678",
		SBOMPackageID: uuid.New(),
		SBOMPackage: SBOMPackage{
			Name:    "test-package",
			Version: "1.0.0",
			Type:    "npm",
		},
		MatchMethod: "purl",
		MatchScore:  0.9,
	}

	if match.MatchMethod != "purl" {
		t.Errorf("expected match method 'purl', got '%s'", match.MatchMethod)
	}
	if match.MatchScore != 0.9 {
		t.Errorf("expected match score 0.9, got %f", match.MatchScore)
	}
}

// =============================================================================
// SBOMPackage Tests
// =============================================================================

func TestSBOMPackage_Structure(t *testing.T) {
	purl := "pkg:npm/lodash@4.17.21"
	cpe := "cpe:2.3:a:lodash:lodash:4.17.21:*:*:*:*:*:*:*"

	pkg := SBOMPackage{
		ID:      uuid.New(),
		SBOMID:  uuid.New(),
		Name:    "lodash",
		Version: "4.17.21",
		Type:    "npm",
		PURL:    &purl,
		CPE:     &cpe,
	}

	if pkg.Name != "lodash" {
		t.Errorf("expected name 'lodash', got '%s'", pkg.Name)
	}
	if pkg.PURL == nil || *pkg.PURL != purl {
		t.Errorf("expected PURL '%s', got '%v'", purl, pkg.PURL)
	}
}

// =============================================================================
// Affected Config Tests
// =============================================================================

func TestAffectedConfig_Structure(t *testing.T) {
	config := AffectedConfig{
		Vendor:    "apache",
		Product:   "log4j",
		Version:   "2.14.1",
		CPE:       "cpe:2.3:a:apache:log4j:2.14.1:*:*:*:*:*:*:*",
		PURL:      "",
		Ecosystem: "maven",
	}

	if config.Vendor != "apache" {
		t.Errorf("expected vendor 'apache', got '%s'", config.Vendor)
	}
	if config.Product != "log4j" {
		t.Errorf("expected product 'log4j', got '%s'", config.Product)
	}
}
