// Package matcher matches CVEs against SBOM packages to identify affected assets.
package matcher

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/quantumlayerhq/ql-rf/pkg/database"
	"github.com/quantumlayerhq/ql-rf/pkg/models"
)

// Matcher finds SBOM packages that match CVE-affected configurations.
type Matcher struct {
	db     *database.DB
	logger *slog.Logger
}

// NewMatcher creates a new CVE-to-package matcher.
func NewMatcher(db *database.DB, logger *slog.Logger) *Matcher {
	return &Matcher{
		db:     db,
		logger: logger.With("component", "matcher"),
	}
}

// PackageMatch represents a match between a CVE and an SBOM package.
type PackageMatch struct {
	CVECacheID    uuid.UUID
	CVEID         string
	SBOMPackageID uuid.UUID
	SBOMPackage   SBOMPackage
	MatchMethod   string  // cpe, purl, name_version
	MatchScore    float64 // 0-1 confidence
}

// SBOMPackage represents an SBOM package from the database.
type SBOMPackage struct {
	ID       uuid.UUID
	SBOMID   uuid.UUID
	Name     string
	Version  string
	Type     string
	PURL     *string
	CPE      *string
	License  *string
	Supplier *string
}

// MatchResult holds the results of CVE matching.
type MatchResult struct {
	CVEID           string
	Matches         []PackageMatch
	ProcessedAt     time.Time
	DurationMs      int64
	AffectedOrgIDs  []uuid.UUID
	AffectedSBOMIDs []uuid.UUID
}

// MatchCVE finds all SBOM packages affected by a CVE.
func (m *Matcher) MatchCVE(ctx context.Context, cve *models.CVECache) (*MatchResult, error) {
	start := time.Now()

	result := &MatchResult{
		CVEID:       cve.CVEID,
		ProcessedAt: start,
		Matches:     []PackageMatch{},
	}

	// Extract affected configurations from CVE
	configs := m.extractAffectedConfigs(cve)
	if len(configs) == 0 {
		m.logger.Debug("no affected configurations found in CVE", "cve_id", cve.CVEID)
		return result, nil
	}

	// Match by different methods
	var allMatches []PackageMatch

	// Method 1: CPE matching (most authoritative)
	cpeMatches, err := m.matchByCPE(ctx, configs)
	if err != nil {
		m.logger.Warn("CPE matching failed", "cve_id", cve.CVEID, "error", err)
	} else {
		allMatches = append(allMatches, cpeMatches...)
	}

	// Method 2: PURL matching (package URLs)
	purlMatches, err := m.matchByPURL(ctx, configs)
	if err != nil {
		m.logger.Warn("PURL matching failed", "cve_id", cve.CVEID, "error", err)
	} else {
		allMatches = append(allMatches, purlMatches...)
	}

	// Method 3: Name + Version matching (fallback)
	nameMatches, err := m.matchByNameVersion(ctx, configs)
	if err != nil {
		m.logger.Warn("name/version matching failed", "cve_id", cve.CVEID, "error", err)
	} else {
		allMatches = append(allMatches, nameMatches...)
	}

	// Deduplicate matches
	result.Matches = m.deduplicateMatches(allMatches)
	result.DurationMs = time.Since(start).Milliseconds()

	// Extract unique org IDs and SBOM IDs
	orgSet := make(map[uuid.UUID]struct{})
	sbomSet := make(map[uuid.UUID]struct{})
	for _, match := range result.Matches {
		sbomSet[match.SBOMPackage.SBOMID] = struct{}{}
	}

	// Look up org IDs for affected SBOMs
	if len(sbomSet) > 0 {
		sbomIDs := make([]uuid.UUID, 0, len(sbomSet))
		for id := range sbomSet {
			sbomIDs = append(sbomIDs, id)
		}

		orgs, err := m.getOrgIDsForSBOMs(ctx, sbomIDs)
		if err != nil {
			m.logger.Warn("failed to get org IDs for SBOMs", "error", err)
		} else {
			for _, orgID := range orgs {
				orgSet[orgID] = struct{}{}
			}
		}
		result.AffectedSBOMIDs = sbomIDs
	}

	for orgID := range orgSet {
		result.AffectedOrgIDs = append(result.AffectedOrgIDs, orgID)
	}

	m.logger.Info("matched CVE against packages",
		"cve_id", cve.CVEID,
		"matches", len(result.Matches),
		"affected_sboms", len(result.AffectedSBOMIDs),
		"affected_orgs", len(result.AffectedOrgIDs),
		"duration_ms", result.DurationMs)

	return result, nil
}

// AffectedConfig represents a CVE-affected package configuration.
type AffectedConfig struct {
	Vendor    string
	Product   string
	Version   string
	CPE       string
	PURL      string
	Ecosystem string
}

// extractAffectedConfigs extracts affected package configurations from CVE data.
func (m *Matcher) extractAffectedConfigs(cve *models.CVECache) []AffectedConfig {
	var configs []AffectedConfig

	// Parse from CPE patterns if available
	if len(cve.AffectedCPEPatterns) > 0 {
		var cpes []string
		if err := json.Unmarshal(cve.AffectedCPEPatterns, &cpes); err == nil {
			for _, cpe := range cpes {
				config := m.parseCPE(cpe)
				if config.Product != "" {
					config.CPE = cpe
					configs = append(configs, config)
				}
			}
		}
	}

	// Parse from raw data if available (for OSV format)
	if len(cve.RawData) > 0 {
		var rawData map[string]interface{}
		if err := json.Unmarshal(cve.RawData, &rawData); err == nil {
			// Check for OSV "affected" array
			if affected, ok := rawData["affected"].([]interface{}); ok {
				for _, aff := range affected {
					if affMap, ok := aff.(map[string]interface{}); ok {
						config := m.parseOSVAffected(affMap)
						if config.Product != "" {
							configs = append(configs, config)
						}
					}
				}
			}

			// Check for NVD "configurations" (CPE match)
			if configurations, ok := rawData["configurations"].([]interface{}); ok {
				for _, cfg := range configurations {
					cfgConfigs := m.parseNVDConfiguration(cfg)
					configs = append(configs, cfgConfigs...)
				}
			}
		}
	}

	return configs
}

// parseCPE parses a CPE 2.3 string into an AffectedConfig.
// CPE format: cpe:2.3:part:vendor:product:version:update:edition:language:sw_edition:target_sw:target_hw:other
func (m *Matcher) parseCPE(cpe string) AffectedConfig {
	config := AffectedConfig{}

	parts := strings.Split(cpe, ":")
	if len(parts) < 6 {
		return config
	}

	// cpe:2.3:a:vendor:product:version...
	if parts[0] == "cpe" && (parts[1] == "2.3" || parts[1] == "/a" || parts[1] == "/o" || parts[1] == "/h") {
		if parts[1] == "2.3" && len(parts) >= 6 {
			config.Vendor = parts[3]
			config.Product = parts[4]
			if len(parts) >= 6 && parts[5] != "*" && parts[5] != "-" {
				config.Version = parts[5]
			}
		}
	}

	return config
}

// parseOSVAffected parses OSV format affected package info.
func (m *Matcher) parseOSVAffected(aff map[string]interface{}) AffectedConfig {
	config := AffectedConfig{}

	if pkg, ok := aff["package"].(map[string]interface{}); ok {
		if name, ok := pkg["name"].(string); ok {
			config.Product = name
		}
		if ecosystem, ok := pkg["ecosystem"].(string); ok {
			config.Ecosystem = ecosystem
		}
		if purl, ok := pkg["purl"].(string); ok {
			config.PURL = purl
		}
	}

	return config
}

// parseNVDConfiguration parses NVD configuration nodes.
func (m *Matcher) parseNVDConfiguration(cfg interface{}) []AffectedConfig {
	var configs []AffectedConfig

	cfgMap, ok := cfg.(map[string]interface{})
	if !ok {
		return configs
	}

	// Parse nodes
	if nodes, ok := cfgMap["nodes"].([]interface{}); ok {
		for _, node := range nodes {
			nodeConfigs := m.parseNVDNode(node)
			configs = append(configs, nodeConfigs...)
		}
	}

	return configs
}

// parseNVDNode parses an NVD configuration node.
func (m *Matcher) parseNVDNode(node interface{}) []AffectedConfig {
	var configs []AffectedConfig

	nodeMap, ok := node.(map[string]interface{})
	if !ok {
		return configs
	}

	// Parse cpeMatch
	if cpeMatch, ok := nodeMap["cpeMatch"].([]interface{}); ok {
		for _, match := range cpeMatch {
			if matchMap, ok := match.(map[string]interface{}); ok {
				if criteria, ok := matchMap["criteria"].(string); ok {
					config := m.parseCPE(criteria)
					if config.Product != "" {
						config.CPE = criteria
						configs = append(configs, config)
					}
				}
			}
		}
	}

	return configs
}

// matchByCPE finds packages matching by CPE.
func (m *Matcher) matchByCPE(ctx context.Context, configs []AffectedConfig) ([]PackageMatch, error) {
	var matches []PackageMatch

	// Collect CPE patterns
	var cpePatterns []string
	for _, cfg := range configs {
		if cfg.CPE != "" {
			// Create pattern from CPE (wildcards -> LIKE pattern)
			pattern := strings.ReplaceAll(cfg.CPE, "*", "%")
			cpePatterns = append(cpePatterns, pattern)
		}
	}

	if len(cpePatterns) == 0 {
		return matches, nil
	}

	// Query packages with matching CPEs
	query := `
		SELECT id, sbom_id, name, version, type, purl, cpe, license, supplier
		FROM sbom_packages
		WHERE cpe IS NOT NULL AND (
			cpe LIKE ANY($1)
		)
	`

	rows, err := m.db.Query(ctx, query, cpePatterns)
	if err != nil {
		return nil, fmt.Errorf("CPE match query failed: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		pkg := SBOMPackage{}
		if err := rows.Scan(&pkg.ID, &pkg.SBOMID, &pkg.Name, &pkg.Version, &pkg.Type, &pkg.PURL, &pkg.CPE, &pkg.License, &pkg.Supplier); err != nil {
			continue
		}
		matches = append(matches, PackageMatch{
			SBOMPackageID: pkg.ID,
			SBOMPackage:   pkg,
			MatchMethod:   "cpe",
			MatchScore:    0.95, // High confidence for CPE match
		})
	}

	return matches, rows.Err()
}

// matchByPURL finds packages matching by Package URL.
func (m *Matcher) matchByPURL(ctx context.Context, configs []AffectedConfig) ([]PackageMatch, error) {
	var matches []PackageMatch

	// Collect PURL patterns
	var purlPatterns []string
	for _, cfg := range configs {
		if cfg.PURL != "" {
			// Normalize PURL for matching
			purlPatterns = append(purlPatterns, cfg.PURL)
		}
	}

	if len(purlPatterns) == 0 {
		return matches, nil
	}

	// Query packages with matching PURLs
	query := `
		SELECT id, sbom_id, name, version, type, purl, cpe, license, supplier
		FROM sbom_packages
		WHERE purl IS NOT NULL AND purl = ANY($1)
	`

	rows, err := m.db.Query(ctx, query, purlPatterns)
	if err != nil {
		return nil, fmt.Errorf("PURL match query failed: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		pkg := SBOMPackage{}
		if err := rows.Scan(&pkg.ID, &pkg.SBOMID, &pkg.Name, &pkg.Version, &pkg.Type, &pkg.PURL, &pkg.CPE, &pkg.License, &pkg.Supplier); err != nil {
			continue
		}
		matches = append(matches, PackageMatch{
			SBOMPackageID: pkg.ID,
			SBOMPackage:   pkg,
			MatchMethod:   "purl",
			MatchScore:    0.90, // High confidence for PURL match
		})
	}

	return matches, rows.Err()
}

// matchByNameVersion finds packages matching by name and version.
func (m *Matcher) matchByNameVersion(ctx context.Context, configs []AffectedConfig) ([]PackageMatch, error) {
	var matches []PackageMatch

	// Collect name/version pairs
	type nameVersion struct {
		name    string
		version string
	}
	var pairs []nameVersion

	for _, cfg := range configs {
		if cfg.Product != "" {
			pairs = append(pairs, nameVersion{
				name:    strings.ToLower(cfg.Product),
				version: cfg.Version,
			})
		}
	}

	if len(pairs) == 0 {
		return matches, nil
	}

	// Build query for name matching (case-insensitive)
	names := make([]string, len(pairs))
	for i, p := range pairs {
		names[i] = p.name
	}

	query := `
		SELECT id, sbom_id, name, version, type, purl, cpe, license, supplier
		FROM sbom_packages
		WHERE LOWER(name) = ANY($1)
	`

	rows, err := m.db.Query(ctx, query, names)
	if err != nil {
		return nil, fmt.Errorf("name/version match query failed: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		pkg := SBOMPackage{}
		if err := rows.Scan(&pkg.ID, &pkg.SBOMID, &pkg.Name, &pkg.Version, &pkg.Type, &pkg.PURL, &pkg.CPE, &pkg.License, &pkg.Supplier); err != nil {
			continue
		}

		// Calculate match score based on version match
		score := 0.5 // Base score for name match
		for _, p := range pairs {
			if strings.ToLower(pkg.Name) == p.name {
				if p.version == "" || p.version == pkg.Version {
					score = 0.75 // Higher score for version match
				}
				break
			}
		}

		matches = append(matches, PackageMatch{
			SBOMPackageID: pkg.ID,
			SBOMPackage:   pkg,
			MatchMethod:   "name_version",
			MatchScore:    score,
		})
	}

	return matches, rows.Err()
}

// deduplicateMatches removes duplicate matches, keeping highest confidence.
func (m *Matcher) deduplicateMatches(matches []PackageMatch) []PackageMatch {
	seen := make(map[uuid.UUID]PackageMatch)

	for _, match := range matches {
		if existing, ok := seen[match.SBOMPackageID]; ok {
			// Keep the higher confidence match
			if match.MatchScore > existing.MatchScore {
				seen[match.SBOMPackageID] = match
			}
		} else {
			seen[match.SBOMPackageID] = match
		}
	}

	result := make([]PackageMatch, 0, len(seen))
	for _, match := range seen {
		result = append(result, match)
	}

	return result
}

// getOrgIDsForSBOMs retrieves organization IDs for the given SBOM IDs.
func (m *Matcher) getOrgIDsForSBOMs(ctx context.Context, sbomIDs []uuid.UUID) ([]uuid.UUID, error) {
	query := `
		SELECT DISTINCT org_id FROM sboms WHERE id = ANY($1)
	`

	rows, err := m.db.Query(ctx, query, sbomIDs)
	if err != nil {
		return nil, fmt.Errorf("org lookup query failed: %w", err)
	}
	defer rows.Close()

	var orgIDs []uuid.UUID
	for rows.Next() {
		var orgID uuid.UUID
		if err := rows.Scan(&orgID); err != nil {
			continue
		}
		orgIDs = append(orgIDs, orgID)
	}

	return orgIDs, rows.Err()
}

// StoreMatches persists CVE matches to the database.
func (m *Matcher) StoreMatches(ctx context.Context, cveCacheID uuid.UUID, cveID string, matches []PackageMatch) error {
	if len(matches) == 0 {
		return nil
	}

	// Use a transaction
	return m.db.WithTx(ctx, func(tx pgx.Tx) error {
		query := `
			INSERT INTO cve_package_matches (id, cve_cache_id, sbom_package_id, match_method, match_score)
			VALUES ($1, $2, $3, $4, $5)
			ON CONFLICT (cve_cache_id, sbom_package_id) DO UPDATE SET
				match_method = EXCLUDED.match_method,
				match_score = EXCLUDED.match_score,
				matched_at = NOW()
		`

		for _, match := range matches {
			_, err := tx.Exec(ctx, query, uuid.New(), cveCacheID, match.SBOMPackageID, match.MatchMethod, match.MatchScore)
			if err != nil {
				return fmt.Errorf("failed to store match: %w", err)
			}
		}

		m.logger.Info("stored CVE matches",
			"cve_id", cveID,
			"matches", len(matches))

		return nil
	})
}
