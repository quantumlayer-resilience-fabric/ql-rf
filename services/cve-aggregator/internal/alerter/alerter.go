// Package alerter creates CVE alerts for organizations when their packages are affected.
package alerter

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/quantumlayerhq/ql-rf/pkg/database"
	"github.com/quantumlayerhq/ql-rf/pkg/models"
	"github.com/quantumlayerhq/ql-rf/services/cve-aggregator/internal/matcher"
)

// Alerter creates and manages CVE alerts for organizations.
type Alerter struct {
	db     *database.DB
	logger *slog.Logger
}

// NewAlerter creates a new CVE alerter.
func NewAlerter(db *database.DB, logger *slog.Logger) *Alerter {
	return &Alerter{
		db:     db,
		logger: logger.With("component", "alerter"),
	}
}

// CreateAlertsForMatches creates CVE alerts for all affected organizations.
func (a *Alerter) CreateAlertsForMatches(ctx context.Context, cve *models.CVECache, result *matcher.MatchResult) ([]uuid.UUID, error) {
	if len(result.Matches) == 0 {
		return nil, nil
	}

	var alertIDs []uuid.UUID

	// Group matches by organization
	orgMatches := make(map[uuid.UUID][]matcher.PackageMatch)
	for _, match := range result.Matches {
		orgID, err := a.getOrgIDForSBOM(ctx, match.SBOMPackage.SBOMID)
		if err != nil {
			a.logger.Warn("failed to get org for SBOM",
				"sbom_id", match.SBOMPackage.SBOMID,
				"error", err)
			continue
		}
		orgMatches[orgID] = append(orgMatches[orgID], match)
	}

	// Create alert for each organization
	for orgID, matches := range orgMatches {
		alertID, err := a.createAlertForOrg(ctx, cve, orgID, matches)
		if err != nil {
			a.logger.Error("failed to create alert for org",
				"org_id", orgID,
				"cve_id", cve.CVEID,
				"error", err)
			continue
		}
		alertIDs = append(alertIDs, alertID)
	}

	return alertIDs, nil
}

// createAlertForOrg creates a CVE alert for a specific organization.
func (a *Alerter) createAlertForOrg(ctx context.Context, cve *models.CVECache, orgID uuid.UUID, matches []matcher.PackageMatch) (uuid.UUID, error) {
	// Check for existing alert
	existingID, err := a.getExistingAlert(ctx, orgID, cve.CVEID)
	if err != nil {
		return uuid.Nil, fmt.Errorf("failed to check existing alert: %w", err)
	}

	if existingID != uuid.Nil {
		// Update existing alert with new matches
		err = a.updateAlertAffectedItems(ctx, existingID, cve.ID, matches)
		if err != nil {
			return uuid.Nil, fmt.Errorf("failed to update alert affected items: %w", err)
		}
		a.logger.Info("updated existing alert",
			"alert_id", existingID,
			"cve_id", cve.CVEID,
			"org_id", orgID,
			"matches", len(matches))
		return existingID, nil
	}

	// Calculate urgency score
	urgencyInput := models.UrgencyScoreInput{
		CVSSScore:            0,
		ExploitAvailable:     cve.ExploitAvailable,
		CISAKEVListed:        cve.CISAKEVListed,
		ProductionAssetCount: 0, // Will be calculated later
		TotalAssetCount:      0,
		FleetPercentage:      0,
		EPSSScore:            0,
	}
	if cve.CVSSV3Score != nil {
		urgencyInput.CVSSScore = *cve.CVSSV3Score
	}
	if cve.EPSSScore != nil {
		urgencyInput.EPSSScore = *cve.EPSSScore
	}
	urgencyScore := models.CalculateUrgencyScore(urgencyInput)

	// Create new alert
	alertID := uuid.New()
	err = a.db.WithTx(ctx, func(tx pgx.Tx) error {
		// Insert alert
		query := `
			INSERT INTO cve_alerts (
				id, org_id, cve_cache_id, cve_id, severity, urgency_score,
				status, affected_images_count, affected_assets_count, affected_packages_count,
				first_detected_at, last_checked_at, created_at, updated_at
			) VALUES (
				$1, $2, $3, $4, $5, $6,
				'open', $7, $8, $9,
				NOW(), NOW(), NOW(), NOW()
			)
		`

		// Count unique images and assets affected
		imageCount, assetCount, err := a.countAffectedResources(ctx, matches)
		if err != nil {
			a.logger.Warn("failed to count affected resources", "error", err)
		}

		severity := cve.Severity
		if severity == "" {
			severity = string(models.CVESeverityUnknown)
		}

		_, err = tx.Exec(ctx, query,
			alertID, orgID, cve.ID, cve.CVEID, severity, urgencyScore,
			imageCount, assetCount, len(matches))
		if err != nil {
			return fmt.Errorf("failed to insert alert: %w", err)
		}

		// Insert affected items
		itemQuery := `
			INSERT INTO cve_alert_affected_items (
				id, alert_id, sbom_id, image_id, asset_id, package_id,
				package_name, package_version, package_type, fixed_version,
				created_at
			) VALUES (
				$1, $2, $3, $4, $5, $6,
				$7, $8, $9, $10,
				NOW()
			)
		`

		for _, match := range matches {
			// Get image ID for SBOM
			imageID, err := a.getImageIDForSBOM(ctx, match.SBOMPackage.SBOMID)
			if err != nil {
				a.logger.Warn("failed to get image for SBOM", "sbom_id", match.SBOMPackage.SBOMID)
				continue
			}

			// Get assets for image
			assetIDs, err := a.getAssetIDsForImage(ctx, imageID)
			if err != nil {
				a.logger.Warn("failed to get assets for image", "image_id", imageID)
				assetIDs = []uuid.UUID{} // Continue without assets
			}

			// Create affected item for each asset (or one without asset if none)
			if len(assetIDs) == 0 {
				assetIDs = []uuid.UUID{uuid.Nil}
			}

			for _, assetID := range assetIDs {
				itemID := uuid.New()
				var assetIDPtr *uuid.UUID
				if assetID != uuid.Nil {
					assetIDPtr = &assetID
				}

				_, err = tx.Exec(ctx, itemQuery,
					itemID, alertID, match.SBOMPackage.SBOMID, imageID, assetIDPtr, match.SBOMPackageID,
					match.SBOMPackage.Name, match.SBOMPackage.Version, match.SBOMPackage.Type, nil)
				if err != nil {
					a.logger.Warn("failed to insert affected item",
						"alert_id", alertID,
						"package_id", match.SBOMPackageID,
						"error", err)
				}
			}
		}

		return nil
	})

	if err != nil {
		return uuid.Nil, err
	}

	a.logger.Info("created CVE alert",
		"alert_id", alertID,
		"cve_id", cve.CVEID,
		"org_id", orgID,
		"severity", cve.Severity,
		"urgency_score", urgencyScore,
		"affected_packages", len(matches))

	return alertID, nil
}

// getExistingAlert checks if an alert already exists for this CVE and org.
func (a *Alerter) getExistingAlert(ctx context.Context, orgID uuid.UUID, cveID string) (uuid.UUID, error) {
	query := `
		SELECT id FROM cve_alerts
		WHERE org_id = $1 AND cve_id = $2 AND status != 'resolved'
		LIMIT 1
	`

	var alertID uuid.UUID
	err := a.db.QueryRow(ctx, query, orgID, cveID).Scan(&alertID)
	if err == pgx.ErrNoRows {
		return uuid.Nil, nil
	}
	if err != nil {
		return uuid.Nil, err
	}

	return alertID, nil
}

// updateAlertAffectedItems adds new affected items to an existing alert.
func (a *Alerter) updateAlertAffectedItems(ctx context.Context, alertID uuid.UUID, cveCacheID uuid.UUID, matches []matcher.PackageMatch) error {
	return a.db.WithTx(ctx, func(tx pgx.Tx) error {
		// Update alert last_checked_at
		_, err := tx.Exec(ctx, `
			UPDATE cve_alerts SET last_checked_at = NOW(), updated_at = NOW()
			WHERE id = $1
		`, alertID)
		if err != nil {
			return fmt.Errorf("failed to update alert: %w", err)
		}

		// Add new affected items (upsert to avoid duplicates)
		for _, match := range matches {
			imageID, err := a.getImageIDForSBOM(ctx, match.SBOMPackage.SBOMID)
			if err != nil {
				continue
			}

			_, err = tx.Exec(ctx, `
				INSERT INTO cve_alert_affected_items (
					id, alert_id, sbom_id, image_id, package_id,
					package_name, package_version, package_type, created_at
				) VALUES (
					$1, $2, $3, $4, $5, $6, $7, $8, NOW()
				)
				ON CONFLICT DO NOTHING
			`, uuid.New(), alertID, match.SBOMPackage.SBOMID, imageID, match.SBOMPackageID,
				match.SBOMPackage.Name, match.SBOMPackage.Version, match.SBOMPackage.Type)
			if err != nil {
				a.logger.Warn("failed to upsert affected item", "error", err)
			}
		}

		// Update counts
		_, err = tx.Exec(ctx, `
			UPDATE cve_alerts SET
				affected_packages_count = (SELECT COUNT(DISTINCT package_id) FROM cve_alert_affected_items WHERE alert_id = $1),
				affected_images_count = (SELECT COUNT(DISTINCT image_id) FROM cve_alert_affected_items WHERE alert_id = $1),
				affected_assets_count = (SELECT COUNT(DISTINCT asset_id) FROM cve_alert_affected_items WHERE alert_id = $1 AND asset_id IS NOT NULL),
				updated_at = NOW()
			WHERE id = $1
		`, alertID)

		return err
	})
}

// getOrgIDForSBOM retrieves the organization ID for a given SBOM.
func (a *Alerter) getOrgIDForSBOM(ctx context.Context, sbomID uuid.UUID) (uuid.UUID, error) {
	query := `SELECT org_id FROM sboms WHERE id = $1`
	var orgID uuid.UUID
	err := a.db.QueryRow(ctx, query, sbomID).Scan(&orgID)
	return orgID, err
}

// getImageIDForSBOM retrieves the image ID for a given SBOM.
func (a *Alerter) getImageIDForSBOM(ctx context.Context, sbomID uuid.UUID) (uuid.UUID, error) {
	query := `SELECT image_id FROM sboms WHERE id = $1`
	var imageID uuid.UUID
	err := a.db.QueryRow(ctx, query, sbomID).Scan(&imageID)
	return imageID, err
}

// getAssetIDsForImage retrieves all asset IDs running a given image.
func (a *Alerter) getAssetIDsForImage(ctx context.Context, imageID uuid.UUID) ([]uuid.UUID, error) {
	// Query assets via image_coordinates or image_ref
	query := `
		SELECT DISTINCT a.id
		FROM assets a
		LEFT JOIN image_coordinates ic ON a.id = ic.asset_id
		WHERE ic.image_id = $1 OR a.image_ref = (SELECT platform_image_id FROM images WHERE id = $1)
	`

	rows, err := a.db.Query(ctx, query, imageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var assetIDs []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			continue
		}
		assetIDs = append(assetIDs, id)
	}

	return assetIDs, rows.Err()
}

// countAffectedResources counts unique images and assets affected by the matches.
func (a *Alerter) countAffectedResources(ctx context.Context, matches []matcher.PackageMatch) (imageCount, assetCount int, err error) {
	imageSet := make(map[uuid.UUID]struct{})
	assetSet := make(map[uuid.UUID]struct{})

	for _, match := range matches {
		imageID, err := a.getImageIDForSBOM(ctx, match.SBOMPackage.SBOMID)
		if err != nil {
			continue
		}
		imageSet[imageID] = struct{}{}

		assetIDs, err := a.getAssetIDsForImage(ctx, imageID)
		if err != nil {
			continue
		}
		for _, assetID := range assetIDs {
			assetSet[assetID] = struct{}{}
		}
	}

	return len(imageSet), len(assetSet), nil
}

// ResolveAlert marks an alert as resolved.
func (a *Alerter) ResolveAlert(ctx context.Context, alertID uuid.UUID, resolvedBy string, reason string) error {
	query := `
		UPDATE cve_alerts SET
			status = 'resolved',
			resolved_at = NOW(),
			resolved_by = $2,
			resolution_notes = $3,
			updated_at = NOW()
		WHERE id = $1
	`

	err := a.db.Exec(ctx, query, alertID, resolvedBy, reason)
	if err != nil {
		return fmt.Errorf("failed to resolve alert: %w", err)
	}

	a.logger.Info("resolved CVE alert",
		"alert_id", alertID,
		"resolved_by", resolvedBy)

	return nil
}

// GetUnresolvedAlerts retrieves all unresolved alerts for an organization.
func (a *Alerter) GetUnresolvedAlerts(ctx context.Context, orgID uuid.UUID) ([]models.CVEAlert, error) {
	query := `
		SELECT
			id, org_id, cve_cache_id, cve_id, severity, urgency_score,
			status, affected_images_count, affected_assets_count, affected_packages_count,
			first_seen_at, last_seen_at, assigned_to, resolution_notes,
			resolved_at, resolved_by, created_at, updated_at
		FROM cve_alerts
		WHERE org_id = $1 AND status != 'resolved'
		ORDER BY urgency_score DESC, severity DESC
	`

	rows, err := a.db.Query(ctx, query, orgID)
	if err != nil {
		return nil, fmt.Errorf("failed to query alerts: %w", err)
	}
	defer rows.Close()

	var alerts []models.CVEAlert
	for rows.Next() {
		var alert models.CVEAlert
		err := rows.Scan(
			&alert.ID, &alert.OrgID, &alert.CVECacheID, &alert.CVEID, &alert.Severity, &alert.UrgencyScore,
			&alert.Status, &alert.AffectedImagesCount, &alert.AffectedAssetsCount, &alert.AffectedPackagesCount,
			&alert.FirstSeenAt, &alert.LastSeenAt, &alert.AssignedTo, &alert.ResolutionNotes,
			&alert.ResolvedAt, &alert.ResolvedBy, &alert.CreatedAt, &alert.UpdatedAt)
		if err != nil {
			a.logger.Warn("failed to scan alert row", "error", err)
			continue
		}
		alerts = append(alerts, alert)
	}

	return alerts, rows.Err()
}

// GetAlertsByUrgency retrieves alerts above a certain urgency threshold.
func (a *Alerter) GetAlertsByUrgency(ctx context.Context, minUrgencyScore int) ([]models.CVEAlert, error) {
	query := `
		SELECT
			id, org_id, cve_cache_id, cve_id, severity, urgency_score,
			status, affected_images_count, affected_assets_count, affected_packages_count,
			first_seen_at, last_seen_at, assigned_to, resolution_notes,
			resolved_at, resolved_by, created_at, updated_at
		FROM cve_alerts
		WHERE status != 'resolved' AND urgency_score >= $1
		ORDER BY urgency_score DESC
	`

	rows, err := a.db.Query(ctx, query, minUrgencyScore)
	if err != nil {
		return nil, fmt.Errorf("failed to query alerts: %w", err)
	}
	defer rows.Close()

	var alerts []models.CVEAlert
	for rows.Next() {
		var alert models.CVEAlert
		err := rows.Scan(
			&alert.ID, &alert.OrgID, &alert.CVECacheID, &alert.CVEID, &alert.Severity, &alert.UrgencyScore,
			&alert.Status, &alert.AffectedImagesCount, &alert.AffectedAssetsCount, &alert.AffectedPackagesCount,
			&alert.FirstSeenAt, &alert.LastSeenAt, &alert.AssignedTo, &alert.ResolutionNotes,
			&alert.ResolvedAt, &alert.ResolvedBy, &alert.CreatedAt, &alert.UpdatedAt)
		if err != nil {
			continue
		}
		alerts = append(alerts, alert)
	}

	return alerts, rows.Err()
}

// NotifyHighPriorityAlert triggers notifications for high-priority alerts.
// This would integrate with the notification service.
func (a *Alerter) NotifyHighPriorityAlert(ctx context.Context, alertID uuid.UUID) error {
	// Get alert details
	query := `
		SELECT ca.cve_id, ca.severity, ca.urgency_score, ca.org_id,
		       ca.affected_images_count, ca.affected_assets_count
		FROM cve_alerts ca
		WHERE ca.id = $1
	`

	var cveID, severity string
	var urgencyScore float64
	var orgID uuid.UUID
	var imageCount, assetCount int

	err := a.db.QueryRow(ctx, query, alertID).Scan(
		&cveID, &severity, &urgencyScore, &orgID, &imageCount, &assetCount)
	if err != nil {
		return fmt.Errorf("failed to get alert details: %w", err)
	}

	// Log notification (actual implementation would call notification service)
	a.logger.Info("high priority CVE alert notification",
		"alert_id", alertID,
		"cve_id", cveID,
		"severity", severity,
		"urgency_score", urgencyScore,
		"org_id", orgID,
		"affected_images", imageCount,
		"affected_assets", assetCount,
		"notification_time", time.Now())

	// TODO: Integrate with notification service
	// notifier.Send(ctx, &notification.Event{
	//     Type: notification.EventCVEAlertCritical,
	//     OrgID: orgID,
	//     Data: map[string]any{
	//         "alert_id": alertID,
	//         "cve_id": cveID,
	//         ...
	//     },
	// })

	return nil
}
