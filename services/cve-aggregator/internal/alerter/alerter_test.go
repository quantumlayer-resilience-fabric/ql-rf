package alerter

import (
	"log/slog"
	"os"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/quantumlayerhq/ql-rf/pkg/models"
	"github.com/quantumlayerhq/ql-rf/services/cve-aggregator/internal/matcher"
)

func testLogger() *slog.Logger {
	return slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
}

// =============================================================================
// Alerter Unit Tests
// =============================================================================

func TestAlerter_NewAlerter(t *testing.T) {
	a := NewAlerter(nil, testLogger())
	if a == nil {
		t.Error("expected non-nil alerter")
	}
	if a.logger == nil {
		t.Error("expected logger to be set")
	}
}

// =============================================================================
// Urgency Score Calculation Tests
// =============================================================================

func TestUrgencyScore_CriticalCVE(t *testing.T) {
	cvss := 9.8
	input := models.UrgencyScoreInput{
		CVSSScore:            cvss,
		ExploitAvailable:     true,
		CISAKEVListed:        true,
		ProductionAssetCount: 10,
		TotalAssetCount:      100,
		FleetPercentage:      0.1,
		EPSSScore:            0.8,
	}

	score := models.CalculateUrgencyScore(input)

	// Should be very high (close to 100) with all these factors
	if score < 80 {
		t.Errorf("expected high urgency score for critical CVE, got %d", score)
	}
}

func TestUrgencyScore_LowCVE(t *testing.T) {
	cvss := 2.0
	input := models.UrgencyScoreInput{
		CVSSScore:            cvss,
		ExploitAvailable:     false,
		CISAKEVListed:        false,
		ProductionAssetCount: 0,
		TotalAssetCount:      10,
		FleetPercentage:      0.01,
		EPSSScore:            0.01,
	}

	score := models.CalculateUrgencyScore(input)

	// Should be low
	if score > 40 {
		t.Errorf("expected low urgency score for low severity CVE, got %d", score)
	}
}

func TestUrgencyScore_KEVBonus(t *testing.T) {
	baseInput := models.UrgencyScoreInput{
		CVSSScore:        7.5,
		ExploitAvailable: false,
		CISAKEVListed:    false,
		EPSSScore:        0.5,
	}

	kevInput := models.UrgencyScoreInput{
		CVSSScore:        7.5,
		ExploitAvailable: false,
		CISAKEVListed:    true,
		EPSSScore:        0.5,
	}

	baseScore := models.CalculateUrgencyScore(baseInput)
	kevScore := models.CalculateUrgencyScore(kevInput)

	// KEV should add bonus
	if kevScore <= baseScore {
		t.Errorf("expected KEV listing to increase score: base=%d, kev=%d", baseScore, kevScore)
	}
}

func TestUrgencyScore_ExploitBonus(t *testing.T) {
	baseInput := models.UrgencyScoreInput{
		CVSSScore:        7.5,
		ExploitAvailable: false,
		EPSSScore:        0.5,
	}

	exploitInput := models.UrgencyScoreInput{
		CVSSScore:        7.5,
		ExploitAvailable: true,
		EPSSScore:        0.5,
	}

	baseScore := models.CalculateUrgencyScore(baseInput)
	exploitScore := models.CalculateUrgencyScore(exploitInput)

	// Exploit availability should add bonus
	if exploitScore <= baseScore {
		t.Errorf("expected exploit availability to increase score: base=%d, exploit=%d", baseScore, exploitScore)
	}
}

// =============================================================================
// Match Result Processing Tests
// =============================================================================

func TestCreateAlertsForMatches_EmptyMatches(t *testing.T) {
	a := NewAlerter(nil, testLogger())

	cve := &models.CVECache{
		ID:    uuid.New(),
		CVEID: "CVE-2024-1234",
	}

	result := &matcher.MatchResult{
		CVEID:   "CVE-2024-1234",
		Matches: []matcher.PackageMatch{},
	}

	// Should not error with empty matches
	// (can't test actual DB operations without mock)
	if len(result.Matches) != 0 {
		t.Errorf("expected 0 matches, got %d", len(result.Matches))
	}
	_ = cve
	_ = a
}

// =============================================================================
// Alert Status Tests
// =============================================================================

func TestAlertStatuses(t *testing.T) {
	validStatuses := []string{"open", "investigating", "mitigating", "resolved", "false_positive"}

	for _, status := range validStatuses {
		// Just verify these are valid status strings
		if status == "" {
			t.Error("status should not be empty")
		}
	}
}

// =============================================================================
// CVE Alert Structure Tests
// =============================================================================

func TestCVEAlert_Structure(t *testing.T) {
	now := time.Now()
	alert := models.CVEAlert{
		ID:                    uuid.New(),
		OrgID:                 uuid.New(),
		CVEID:                 "CVE-2024-5678",
		Severity:              "critical",
		UrgencyScore:          85,
		Status:                "open",
		AffectedImagesCount:   5,
		AffectedAssetsCount:   20,
		AffectedPackagesCount: 3,
		FirstSeenAt:           now,
		LastSeenAt:            now,
		CreatedAt:             now,
		UpdatedAt:             now,
	}

	if alert.CVEID != "CVE-2024-5678" {
		t.Errorf("expected CVE ID 'CVE-2024-5678', got '%s'", alert.CVEID)
	}
	if alert.Severity != "critical" {
		t.Errorf("expected severity 'critical', got '%s'", alert.Severity)
	}
	if alert.UrgencyScore != 85 {
		t.Errorf("expected urgency score 85, got %d", alert.UrgencyScore)
	}
}

// =============================================================================
// Alert Affected Item Tests
// =============================================================================

func TestCVEAlertAffectedItem_Structure(t *testing.T) {
	now := time.Now()
	imageID := uuid.New()
	assetID := uuid.New()
	packageName := "lodash"
	packageVersion := "4.17.0"
	packageType := "npm"

	item := models.CVEAlertAffectedItem{
		ID:             uuid.New(),
		AlertID:        uuid.New(),
		ImageID:        &imageID,
		AssetID:        &assetID,
		ItemType:       "package",
		PackageName:    &packageName,
		PackageVersion: &packageVersion,
		PackageType:    &packageType,
		FixedVersion:   strPtr("4.17.21"),
		CreatedAt:      now,
	}

	if item.PackageName == nil || *item.PackageName != "lodash" {
		t.Errorf("expected package name 'lodash', got '%v'", item.PackageName)
	}
	if item.FixedVersion == nil || *item.FixedVersion != "4.17.21" {
		t.Errorf("expected fixed version '4.17.21', got '%v'", item.FixedVersion)
	}
}

// Helper function
func strPtr(s string) *string {
	return &s
}

// =============================================================================
// Alert Priority Tests
// =============================================================================

func TestAlertPriority_ShouldBeP1ForCritical(t *testing.T) {
	// P1: Critical CVEs with CISA KEV or exploit
	alert := models.CVEAlert{
		Severity:     "critical",
		UrgencyScore: 95,
	}

	// With high urgency score, should be P1
	if alert.UrgencyScore < 80 {
		t.Error("critical CVE with high urgency should be P1")
	}
}

func TestAlertPriority_ShouldBeP4ForLow(t *testing.T) {
	// P4: Low severity CVEs
	alert := models.CVEAlert{
		Severity:     "low",
		UrgencyScore: 15,
	}

	if alert.UrgencyScore > 30 {
		t.Error("low severity CVE should have low urgency")
	}
}

// =============================================================================
// Resolution Type Tests
// =============================================================================

func TestResolutionTypes(t *testing.T) {
	validResolutions := []string{
		"patched",
		"mitigated",
		"accepted_risk",
		"false_positive",
		"not_affected",
	}

	for _, resolution := range validResolutions {
		if resolution == "" {
			t.Error("resolution type should not be empty")
		}
	}
}

// =============================================================================
// Alert Counts Tests
// =============================================================================

func TestAlertCounts_ConsistentCounting(t *testing.T) {
	alert := models.CVEAlert{
		AffectedImagesCount:   3,
		AffectedAssetsCount:   15,
		AffectedPackagesCount: 5,
		ProductionAssetsCount: 10,
	}

	// Production assets should be <= total assets
	if alert.ProductionAssetsCount > alert.AffectedAssetsCount {
		t.Error("production assets should not exceed total assets")
	}
}

// =============================================================================
// SLA Tests
// =============================================================================

func TestSLA_CriticalDueDate(t *testing.T) {
	// Critical CVEs typically have 15-day SLA
	now := time.Now()
	dueDate := now.Add(15 * 24 * time.Hour)

	alert := models.CVEAlert{
		Severity: "critical",
		SLADueAt: &dueDate,
	}

	if alert.SLADueAt == nil {
		t.Error("critical CVE should have SLA due date")
	}

	// Should be within 15 days
	if alert.SLADueAt.Sub(now) > 16*24*time.Hour {
		t.Error("critical CVE SLA should be within 15 days")
	}
}

func TestSLA_HighDueDate(t *testing.T) {
	// High severity CVEs typically have 30-day SLA
	now := time.Now()
	dueDate := now.Add(30 * 24 * time.Hour)

	alert := models.CVEAlert{
		Severity: "high",
		SLADueAt: &dueDate,
	}

	if alert.SLADueAt == nil {
		t.Error("high severity CVE should have SLA due date")
	}
}

// =============================================================================
// Alert Lifecycle Tests
// =============================================================================

func TestAlertLifecycle_NewToResolved(t *testing.T) {
	now := time.Now()

	// New alert
	alert := models.CVEAlert{
		ID:          uuid.New(),
		Status:      "open",
		FirstSeenAt: now,
		LastSeenAt:  now,
		CreatedAt:   now,
		UpdatedAt:   now,
	}

	if alert.Status != "open" {
		t.Error("new alert should be 'open'")
	}

	// Investigating
	alert.Status = "investigating"
	alert.UpdatedAt = time.Now()

	if alert.Status != "investigating" {
		t.Error("alert should be 'investigating'")
	}

	// Resolved
	resolvedAt := time.Now()
	resolvedBy := "security-team"
	alert.Status = "resolved"
	alert.ResolvedAt = &resolvedAt
	alert.ResolvedBy = &resolvedBy
	alert.UpdatedAt = time.Now()

	if alert.Status != "resolved" {
		t.Error("alert should be 'resolved'")
	}
	if alert.ResolvedAt == nil {
		t.Error("resolved alert should have ResolvedAt timestamp")
	}
	if alert.ResolvedBy == nil || *alert.ResolvedBy != "security-team" {
		t.Error("resolved alert should have ResolvedBy")
	}
}

// =============================================================================
// Package Match to Alert Item Mapping Tests
// =============================================================================

func TestMatchToAlertItem_Mapping(t *testing.T) {
	match := matcher.PackageMatch{
		SBOMPackageID: uuid.New(),
		SBOMPackage: matcher.SBOMPackage{
			ID:      uuid.New(),
			SBOMID:  uuid.New(),
			Name:    "express",
			Version: "4.17.1",
			Type:    "npm",
		},
		MatchMethod: "purl",
		MatchScore:  0.95,
	}

	// Verify match data can map to alert item
	if match.SBOMPackage.Name != "express" {
		t.Errorf("expected package name 'express', got '%s'", match.SBOMPackage.Name)
	}
	if match.SBOMPackage.Version != "4.17.1" {
		t.Errorf("expected version '4.17.1', got '%s'", match.SBOMPackage.Version)
	}
}
