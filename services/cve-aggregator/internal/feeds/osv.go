package feeds

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/quantumlayerhq/ql-rf/pkg/models"
)

const (
	osvBaseURL    = "https://api.osv.dev/v1"
	osvQueryURL   = "https://api.osv.dev/v1/query"
	osvVulnsURL   = "https://api.osv.dev/v1/vulns"
)

// OSVFeed implements the Feed interface for OSV (Open Source Vulnerabilities).
type OSVFeed struct {
	httpClient *http.Client
	logger     *slog.Logger
}

// NewOSVFeed creates a new OSV feed client.
func NewOSVFeed(logger *slog.Logger) *OSVFeed {
	return &OSVFeed{
		httpClient: &http.Client{
			Timeout: 60 * time.Second,
		},
		logger: logger.With("feed", "osv"),
	}
}

// Name returns the unique identifier for this feed.
func (f *OSVFeed) Name() string {
	return "osv"
}

// DisplayName returns a human-readable name for this feed.
func (f *OSVFeed) DisplayName() string {
	return "OSV (Open Source Vulnerabilities)"
}

// Priority returns the source priority (lower = more authoritative).
func (f *OSVFeed) Priority() int {
	return 20
}

// HealthCheck verifies the feed is accessible.
func (f *OSVFeed) HealthCheck(ctx context.Context) error {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, osvBaseURL, nil)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := f.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to reach OSV API: %w", err)
	}
	defer resp.Body.Close()

	// OSV returns 200 for the base URL
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNotFound {
		return fmt.Errorf("OSV API returned status %d", resp.StatusCode)
	}

	return nil
}

// FetchCVEs retrieves CVEs modified since the given timestamp.
// OSV doesn't have a time-based query, so we rely on batched PURL queries.
// This method is mainly used for enriching existing CVEs with OSV data.
func (f *OSVFeed) FetchCVEs(ctx context.Context, since time.Time) ([]*models.CVECache, error) {
	// OSV doesn't support time-based querying of all vulnerabilities
	// This feed is primarily used for package-specific queries via QueryByPackage
	f.logger.Warn("OSV feed does not support time-based CVE fetching; use QueryByPackage instead")
	return []*models.CVECache{}, nil
}

// FetchCVE retrieves a specific vulnerability by ID.
func (f *OSVFeed) FetchCVE(ctx context.Context, vulnID string) (*models.CVECache, error) {
	reqURL := fmt.Sprintf("%s/%s", osvVulnsURL, vulnID)
	f.logger.Debug("fetching vulnerability from OSV", "vulnId", vulnID)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := f.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch vulnerability: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode == http.StatusNotFound {
		return nil, fmt.Errorf("vulnerability %s not found", vulnID)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("OSV API returned status %d: %s", resp.StatusCode, string(body))
	}

	var osvVuln OSVVulnerability
	if err := json.Unmarshal(body, &osvVuln); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	return f.convertToCVECache(osvVuln), nil
}

// QueryByPackage queries OSV for vulnerabilities affecting a specific package.
func (f *OSVFeed) QueryByPackage(ctx context.Context, ecosystem, name, version string) ([]*models.CVECache, error) {
	query := OSVQuery{
		Package: &OSVPackage{
			Ecosystem: ecosystem,
			Name:      name,
		},
	}

	if version != "" {
		query.Version = version
	}

	body, err := json.Marshal(query)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal query: %w", err)
	}

	f.logger.Debug("querying OSV for package",
		"ecosystem", ecosystem,
		"name", name,
		"version", version)

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, osvQueryURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := f.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to query OSV: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("OSV API returned status %d: %s", resp.StatusCode, string(respBody))
	}

	var queryResp OSVQueryResponse
	if err := json.Unmarshal(respBody, &queryResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	var cves []*models.CVECache
	for _, vuln := range queryResp.Vulns {
		cves = append(cves, f.convertToCVECache(vuln))
	}

	f.logger.Info("queried OSV for package",
		"ecosystem", ecosystem,
		"name", name,
		"version", version,
		"vulns_found", len(cves))

	return cves, nil
}

// QueryByPURL queries OSV using a Package URL.
func (f *OSVFeed) QueryByPURL(ctx context.Context, purl string) ([]*models.CVECache, error) {
	query := OSVQuery{
		Package: &OSVPackage{
			PURL: purl,
		},
	}

	body, err := json.Marshal(query)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal query: %w", err)
	}

	f.logger.Debug("querying OSV by PURL", "purl", purl)

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, osvQueryURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := f.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to query OSV: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("OSV API returned status %d: %s", resp.StatusCode, string(respBody))
	}

	var queryResp OSVQueryResponse
	if err := json.Unmarshal(respBody, &queryResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	var cves []*models.CVECache
	for _, vuln := range queryResp.Vulns {
		cves = append(cves, f.convertToCVECache(vuln))
	}

	return cves, nil
}

// convertToCVECache converts OSV vulnerability data to our CVECache model.
func (f *OSVFeed) convertToCVECache(vuln OSVVulnerability) *models.CVECache {
	cve := &models.CVECache{
		ID:            uuid.New(),
		CVEID:         vuln.ID,
		PrimarySource: "osv",
		FetchedAt:     time.Now(),
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
		Severity:      string(models.CVESeverityUnknown),
	}

	// OSV may have a CVE alias
	for _, alias := range vuln.Aliases {
		if strings.HasPrefix(alias, "CVE-") {
			cve.CVEID = alias
			break
		}
	}

	// Parse summary/details
	if vuln.Summary != "" {
		cve.Description = &vuln.Summary
	} else if vuln.Details != "" {
		cve.Description = &vuln.Details
	}

	// Parse dates
	if vuln.Published != "" {
		if t, err := time.Parse(time.RFC3339, vuln.Published); err == nil {
			cve.PublishedDate = &t
		}
	}
	if vuln.Modified != "" {
		if t, err := time.Parse(time.RFC3339, vuln.Modified); err == nil {
			cve.ModifiedDate = &t
		}
	}

	// Parse severity
	for _, severity := range vuln.Severity {
		if severity.Type == "CVSS_V3" {
			cve.CVSSV3Vector = &severity.Score
			// Parse CVSS score from vector
			score := parseScoreFromCVSSVector(severity.Score)
			if score > 0 {
				cve.CVSSV3Score = &score
				cve.Severity = string(models.SeverityFromCVSS(score))
			}
		}
	}

	// Check database-specific severity
	if len(vuln.DatabaseSpecific) > 0 {
		if sevData, ok := vuln.DatabaseSpecific["severity"].(string); ok {
			cve.Severity = strings.ToLower(sevData)
		}
	}

	// Parse references
	if len(vuln.References) > 0 {
		refs := make([]map[string]string, 0, len(vuln.References))
		for _, ref := range vuln.References {
			r := map[string]string{
				"url":  ref.URL,
				"type": ref.Type,
			}
			refs = append(refs, r)
		}
		if data, err := json.Marshal(refs); err == nil {
			cve.ReferenceURLs = data
		}
	}

	// Set sources
	sources := []string{"osv"}
	if data, err := json.Marshal(sources); err == nil {
		cve.Sources = data
	}

	// Store raw data
	if data, err := json.Marshal(vuln); err == nil {
		cve.RawData = data
	}

	return cve
}

// parseScoreFromCVSSVector extracts the base score from a CVSS v3 vector.
// This is a simplified parser - in production, use a proper CVSS library.
func parseScoreFromCVSSVector(vector string) float64 {
	// Example vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
	// We can't accurately calculate the score without a proper CVSS calculator
	// For now, return 0 and let other sources provide the score
	return 0
}

// =============================================================================
// OSV API Types
// =============================================================================

// OSVQuery represents an OSV query request.
type OSVQuery struct {
	Package *OSVPackage `json:"package,omitempty"`
	Version string      `json:"version,omitempty"`
	Commit  string      `json:"commit,omitempty"`
}

// OSVPackage represents a package in OSV.
type OSVPackage struct {
	Name      string `json:"name,omitempty"`
	Ecosystem string `json:"ecosystem,omitempty"`
	PURL      string `json:"purl,omitempty"`
}

// OSVQueryResponse represents the response from an OSV query.
type OSVQueryResponse struct {
	Vulns []OSVVulnerability `json:"vulns"`
}

// OSVVulnerability represents a vulnerability in OSV format.
type OSVVulnerability struct {
	ID               string                 `json:"id"`
	Summary          string                 `json:"summary"`
	Details          string                 `json:"details"`
	Aliases          []string               `json:"aliases"`
	Modified         string                 `json:"modified"`
	Published        string                 `json:"published"`
	Withdrawn        string                 `json:"withdrawn,omitempty"`
	References       []OSVReference         `json:"references"`
	Affected         []OSVAffected          `json:"affected"`
	Severity         []OSVSeverity          `json:"severity"`
	DatabaseSpecific map[string]interface{} `json:"database_specific"`
}

// OSVReference represents a reference in OSV.
type OSVReference struct {
	Type string `json:"type"`
	URL  string `json:"url"`
}

// OSVAffected represents affected packages in OSV.
type OSVAffected struct {
	Package           OSVPackage             `json:"package"`
	Ranges            []OSVRange             `json:"ranges"`
	Versions          []string               `json:"versions"`
	DatabaseSpecific  map[string]interface{} `json:"database_specific"`
	EcosystemSpecific map[string]interface{} `json:"ecosystem_specific"`
}

// OSVRange represents version ranges in OSV.
type OSVRange struct {
	Type   string      `json:"type"` // SEMVER, ECOSYSTEM, GIT
	Events []OSVEvent  `json:"events"`
}

// OSVEvent represents a version event in OSV.
type OSVEvent struct {
	Introduced   string `json:"introduced,omitempty"`
	Fixed        string `json:"fixed,omitempty"`
	LastAffected string `json:"last_affected,omitempty"`
	Limit        string `json:"limit,omitempty"`
}

// OSVSeverity represents severity information in OSV.
type OSVSeverity struct {
	Type  string `json:"type"`  // CVSS_V2, CVSS_V3
	Score string `json:"score"` // The CVSS vector string
}
