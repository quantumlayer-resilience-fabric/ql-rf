package feeds

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"time"

	"github.com/google/uuid"
	"github.com/quantumlayerhq/ql-rf/pkg/models"
)

const (
	cisaKEVURL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
)

// CISAKEVFeed implements the Feed interface for CISA Known Exploited Vulnerabilities catalog.
type CISAKEVFeed struct {
	httpClient *http.Client
	logger     *slog.Logger
}

// NewCISAKEVFeed creates a new CISA KEV feed client.
func NewCISAKEVFeed(logger *slog.Logger) *CISAKEVFeed {
	return &CISAKEVFeed{
		httpClient: &http.Client{
			Timeout: 60 * time.Second,
		},
		logger: logger.With("feed", "cisa_kev"),
	}
}

// Name returns the unique identifier for this feed.
func (f *CISAKEVFeed) Name() string {
	return "cisa_kev"
}

// DisplayName returns a human-readable name for this feed.
func (f *CISAKEVFeed) DisplayName() string {
	return "CISA Known Exploited Vulnerabilities"
}

// Priority returns the source priority (lower = more authoritative).
// CISA KEV has highest priority because if a CVE is here, it's being actively exploited.
func (f *CISAKEVFeed) Priority() int {
	return 5
}

// HealthCheck verifies the feed is accessible.
func (f *CISAKEVFeed) HealthCheck(ctx context.Context) error {
	req, err := http.NewRequestWithContext(ctx, http.MethodHead, cisaKEVURL, nil)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := f.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to reach CISA KEV API: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("CISA KEV API returned status %d", resp.StatusCode)
	}

	return nil
}

// FetchCVEs retrieves all CVEs in the KEV catalog.
// The CISA KEV catalog is relatively small (~1000 CVEs) so we fetch all of them.
func (f *CISAKEVFeed) FetchCVEs(ctx context.Context, since time.Time) ([]*models.CVECache, error) {
	f.logger.Debug("fetching CISA KEV catalog")

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, cisaKEVURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := f.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch CISA KEV: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("CISA KEV API returned status %d: %s", resp.StatusCode, string(body))
	}

	var kevResp CISAKEVResponse
	if err := json.Unmarshal(body, &kevResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	var cves []*models.CVECache
	for _, vuln := range kevResp.Vulnerabilities {
		// Filter by date if provided
		if !since.IsZero() {
			dateAdded, err := time.Parse("2006-01-02", vuln.DateAdded)
			if err == nil && dateAdded.Before(since) {
				continue
			}
		}

		cve := f.convertToCVECache(vuln)
		cves = append(cves, cve)
	}

	f.logger.Info("fetched CISA KEV catalog",
		"total", kevResp.Count,
		"filtered", len(cves))

	return cves, nil
}

// FetchCVE retrieves a specific CVE from the KEV catalog.
// Note: CISA KEV doesn't have a per-CVE endpoint, so we fetch all and filter.
func (f *CISAKEVFeed) FetchCVE(ctx context.Context, cveID string) (*models.CVECache, error) {
	cves, err := f.FetchCVEs(ctx, time.Time{})
	if err != nil {
		return nil, err
	}

	for _, cve := range cves {
		if cve.CVEID == cveID {
			return cve, nil
		}
	}

	return nil, fmt.Errorf("CVE %s not found in CISA KEV catalog", cveID)
}

// convertToCVECache converts CISA KEV data to our CVECache model.
// Note: CISA KEV doesn't provide full CVE details, just the fact that it's exploited.
// This should be merged with data from other sources (NVD, etc.)
func (f *CISAKEVFeed) convertToCVECache(vuln CISAKEVVulnerability) *models.CVECache {
	cve := &models.CVECache{
		ID:               uuid.New(),
		CVEID:            vuln.CVEID,
		PrimarySource:    "cisa_kev",
		CISAKEVListed:    true,
		ExploitAvailable: true, // If it's in KEV, exploits exist
		FetchedAt:        time.Now(),
		CreatedAt:        time.Now(),
		UpdatedAt:        time.Now(),
		Severity:         string(models.CVESeverityCritical), // KEV CVEs are critical by definition
	}

	// Parse dates
	if vuln.DateAdded != "" {
		if t, err := time.Parse("2006-01-02", vuln.DateAdded); err == nil {
			cve.CISAKEVAddedDate = &t
		}
	}

	if vuln.DueDate != "" {
		if t, err := time.Parse("2006-01-02", vuln.DueDate); err == nil {
			cve.CISAKEVDueDate = &t
		}
	}

	// Check for ransomware indicator
	if vuln.KnownRansomwareCampaignUse == "Known" {
		ransomware := true
		cve.CISAKEVRansomware = &ransomware
	}

	// Set description from short description
	if vuln.ShortDescription != "" {
		cve.Description = &vuln.ShortDescription
	}

	// Set remediation notes
	if vuln.RequiredAction != "" {
		cve.RemediationSummary = &vuln.RequiredAction
	}

	// Set sources
	sources := []string{"cisa_kev"}
	if data, err := json.Marshal(sources); err == nil {
		cve.Sources = data
	}

	// Store raw data
	if data, err := json.Marshal(vuln); err == nil {
		cve.RawData = data
	}

	return cve
}

// =============================================================================
// CISA KEV API Response Types
// =============================================================================

// CISAKEVResponse represents the CISA KEV API response.
type CISAKEVResponse struct {
	Title            string                `json:"title"`
	CatalogVersion   string                `json:"catalogVersion"`
	DateReleased     string                `json:"dateReleased"`
	Count            int                   `json:"count"`
	Vulnerabilities  []CISAKEVVulnerability `json:"vulnerabilities"`
}

// CISAKEVVulnerability represents a vulnerability in the KEV catalog.
type CISAKEVVulnerability struct {
	CVEID                       string `json:"cveID"`
	VendorProject               string `json:"vendorProject"`
	Product                     string `json:"product"`
	VulnerabilityName           string `json:"vulnerabilityName"`
	DateAdded                   string `json:"dateAdded"`
	ShortDescription            string `json:"shortDescription"`
	RequiredAction              string `json:"requiredAction"`
	DueDate                     string `json:"dueDate"`
	KnownRansomwareCampaignUse  string `json:"knownRansomwareCampaignUse"` // "Known" or "Unknown"
	Notes                       string `json:"notes"`
}
