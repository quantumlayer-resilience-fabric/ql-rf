package feeds

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/quantumlayerhq/ql-rf/pkg/models"
)

const (
	githubGraphQLURL = "https://api.github.com/graphql"
)

// GitHubAdvisoryFeed implements the Feed interface for GitHub Security Advisories.
type GitHubAdvisoryFeed struct {
	httpClient *http.Client
	logger     *slog.Logger
	token      string
}

// NewGitHubAdvisoryFeed creates a new GitHub Advisory feed client.
func NewGitHubAdvisoryFeed(token string, logger *slog.Logger) *GitHubAdvisoryFeed {
	return &GitHubAdvisoryFeed{
		httpClient: &http.Client{
			Timeout: 60 * time.Second,
		},
		logger: logger.With("feed", "github"),
		token:  token,
	}
}

// Name returns the unique identifier for this feed.
func (f *GitHubAdvisoryFeed) Name() string {
	return "github"
}

// DisplayName returns a human-readable name for this feed.
func (f *GitHubAdvisoryFeed) DisplayName() string {
	return "GitHub Security Advisories"
}

// Priority returns the source priority (lower = more authoritative).
func (f *GitHubAdvisoryFeed) Priority() int {
	return 15
}

// HealthCheck verifies the feed is accessible.
func (f *GitHubAdvisoryFeed) HealthCheck(ctx context.Context) error {
	if f.token == "" {
		return fmt.Errorf("GitHub token not configured")
	}

	// Simple query to test API access
	query := `{"query": "query { viewer { login } }"}`

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, githubGraphQLURL, strings.NewReader(query))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "bearer "+f.token)
	req.Header.Set("Content-Type", "application/json")

	resp, err := f.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to reach GitHub API: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("GitHub API returned status %d: %s", resp.StatusCode, string(body))
	}

	return nil
}

// FetchCVEs retrieves CVEs modified since the given timestamp.
func (f *GitHubAdvisoryFeed) FetchCVEs(ctx context.Context, since time.Time) ([]*models.CVECache, error) {
	if f.token == "" {
		f.logger.Warn("GitHub token not configured; skipping GitHub Advisory feed")
		return []*models.CVECache{}, nil
	}

	f.logger.Debug("fetching GitHub Advisories", "since", since)

	var allCVEs []*models.CVECache
	hasNextPage := true
	cursor := ""

	for hasNextPage {
		// Build GraphQL query
		query := f.buildQuery(since, cursor)

		req, err := http.NewRequestWithContext(ctx, http.MethodPost, githubGraphQLURL, bytes.NewReader(query))
		if err != nil {
			return nil, fmt.Errorf("failed to create request: %w", err)
		}

		req.Header.Set("Authorization", "bearer "+f.token)
		req.Header.Set("Content-Type", "application/json")

		resp, err := f.httpClient.Do(req)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch GitHub Advisories: %w", err)
		}

		body, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			return nil, fmt.Errorf("failed to read response: %w", err)
		}

		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("GitHub API returned status %d: %s", resp.StatusCode, string(body))
		}

		var gqlResp GitHubGraphQLResponse
		if err := json.Unmarshal(body, &gqlResp); err != nil {
			return nil, fmt.Errorf("failed to parse response: %w", err)
		}

		if len(gqlResp.Errors) > 0 {
			return nil, fmt.Errorf("GraphQL error: %s", gqlResp.Errors[0].Message)
		}

		// Process advisories
		for _, edge := range gqlResp.Data.SecurityAdvisories.Edges {
			cve := f.convertToCVECache(edge.Node)
			if cve != nil {
				allCVEs = append(allCVEs, cve)
			}
		}

		hasNextPage = gqlResp.Data.SecurityAdvisories.PageInfo.HasNextPage
		cursor = gqlResp.Data.SecurityAdvisories.PageInfo.EndCursor

		f.logger.Debug("fetched GitHub Advisory page",
			"count", len(gqlResp.Data.SecurityAdvisories.Edges),
			"hasNextPage", hasNextPage)

		// Rate limit: GitHub allows 5000 requests/hour with authentication
		// Sleep briefly between pages to be respectful
		if hasNextPage {
			time.Sleep(100 * time.Millisecond)
		}
	}

	f.logger.Info("fetched GitHub Advisories",
		"total", len(allCVEs),
		"since", since)

	return allCVEs, nil
}

// FetchCVE retrieves a specific vulnerability by ID.
func (f *GitHubAdvisoryFeed) FetchCVE(ctx context.Context, cveID string) (*models.CVECache, error) {
	if f.token == "" {
		return nil, fmt.Errorf("GitHub token not configured")
	}

	// Query for a specific CVE by its identifier
	query := fmt.Sprintf(`{
		"query": "query { securityAdvisory(ghsaId: \"%s\") { ghsaId summary description severity publishedAt updatedAt cvss { score vectorString } identifiers { type value } references { url } vulnerabilities(first: 100) { nodes { package { ecosystem name } vulnerableVersionRange firstPatchedVersion { identifier } } } } }"
	}`, cveID)

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, githubGraphQLURL, strings.NewReader(query))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "bearer "+f.token)
	req.Header.Set("Content-Type", "application/json")

	resp, err := f.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch advisory: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GitHub API returned status %d: %s", resp.StatusCode, string(body))
	}

	var gqlResp struct {
		Data struct {
			SecurityAdvisory *GitHubAdvisory `json:"securityAdvisory"`
		} `json:"data"`
		Errors []GitHubGraphQLError `json:"errors"`
	}

	if err := json.Unmarshal(body, &gqlResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	if len(gqlResp.Errors) > 0 {
		return nil, fmt.Errorf("GraphQL error: %s", gqlResp.Errors[0].Message)
	}

	if gqlResp.Data.SecurityAdvisory == nil {
		return nil, fmt.Errorf("advisory %s not found", cveID)
	}

	return f.convertToCVECache(*gqlResp.Data.SecurityAdvisory), nil
}

// buildQuery constructs the GraphQL query for fetching advisories.
func (f *GitHubAdvisoryFeed) buildQuery(since time.Time, cursor string) []byte {
	afterClause := ""
	if cursor != "" {
		afterClause = fmt.Sprintf(`, after: "%s"`, cursor)
	}

	// Format the since time for the query
	sinceStr := since.Format(time.RFC3339)

	query := fmt.Sprintf(`{
		"query": "query { securityAdvisories(first: 100, updatedSince: \"%s\"%s) { pageInfo { hasNextPage endCursor } edges { node { ghsaId summary description severity publishedAt updatedAt cvss { score vectorString } identifiers { type value } references { url } vulnerabilities(first: 100) { nodes { package { ecosystem name } vulnerableVersionRange firstPatchedVersion { identifier } } } } } } }"
	}`, sinceStr, afterClause)

	return []byte(query)
}

// convertToCVECache converts a GitHub Advisory to our CVECache model.
func (f *GitHubAdvisoryFeed) convertToCVECache(advisory GitHubAdvisory) *models.CVECache {
	cve := &models.CVECache{
		ID:            uuid.New(),
		CVEID:         advisory.GHSAId,
		PrimarySource: "github",
		FetchedAt:     time.Now(),
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
		Severity:      strings.ToLower(advisory.Severity),
	}

	// Find CVE ID from identifiers (prefer CVE over GHSA)
	for _, id := range advisory.Identifiers {
		if id.Type == "CVE" && strings.HasPrefix(id.Value, "CVE-") {
			cve.CVEID = id.Value
			break
		}
	}

	// Set description
	if advisory.Summary != "" {
		cve.Description = &advisory.Summary
	} else if advisory.Description != "" {
		cve.Description = &advisory.Description
	}

	// Parse dates
	if advisory.PublishedAt != "" {
		if t, err := time.Parse(time.RFC3339, advisory.PublishedAt); err == nil {
			cve.PublishedDate = &t
		}
	}
	if advisory.UpdatedAt != "" {
		if t, err := time.Parse(time.RFC3339, advisory.UpdatedAt); err == nil {
			cve.ModifiedDate = &t
		}
	}

	// Parse CVSS
	if advisory.CVSS.Score > 0 {
		cve.CVSSV3Score = &advisory.CVSS.Score
		if advisory.CVSS.VectorString != "" {
			cve.CVSSV3Vector = &advisory.CVSS.VectorString
		}
		cve.Severity = string(models.SeverityFromCVSS(advisory.CVSS.Score))
	}

	// Parse references
	if len(advisory.References) > 0 {
		refs := make([]map[string]string, 0, len(advisory.References))
		for _, ref := range advisory.References {
			r := map[string]string{
				"url":  ref.URL,
				"type": "ADVISORY",
			}
			refs = append(refs, r)
		}
		if data, err := json.Marshal(refs); err == nil {
			cve.ReferenceURLs = data
		}
	}

	// Set sources
	sources := []string{"github"}
	if data, err := json.Marshal(sources); err == nil {
		cve.Sources = data
	}

	// Store raw data
	if data, err := json.Marshal(advisory); err == nil {
		cve.RawData = data
	}

	return cve
}

// =============================================================================
// GitHub GraphQL Types
// =============================================================================

// GitHubGraphQLResponse represents the top-level GraphQL response.
type GitHubGraphQLResponse struct {
	Data struct {
		SecurityAdvisories struct {
			PageInfo GitHubPageInfo         `json:"pageInfo"`
			Edges    []GitHubAdvisoryEdge   `json:"edges"`
		} `json:"securityAdvisories"`
	} `json:"data"`
	Errors []GitHubGraphQLError `json:"errors"`
}

// GitHubGraphQLError represents a GraphQL error.
type GitHubGraphQLError struct {
	Message string `json:"message"`
}

// GitHubPageInfo represents pagination info.
type GitHubPageInfo struct {
	HasNextPage bool   `json:"hasNextPage"`
	EndCursor   string `json:"endCursor"`
}

// GitHubAdvisoryEdge represents an edge in the advisories connection.
type GitHubAdvisoryEdge struct {
	Node GitHubAdvisory `json:"node"`
}

// GitHubAdvisory represents a GitHub Security Advisory.
type GitHubAdvisory struct {
	GHSAId          string                     `json:"ghsaId"`
	Summary         string                     `json:"summary"`
	Description     string                     `json:"description"`
	Severity        string                     `json:"severity"`
	PublishedAt     string                     `json:"publishedAt"`
	UpdatedAt       string                     `json:"updatedAt"`
	CVSS            GitHubCVSS                 `json:"cvss"`
	Identifiers     []GitHubIdentifier         `json:"identifiers"`
	References      []GitHubReference          `json:"references"`
	Vulnerabilities GitHubVulnerabilitiesConn  `json:"vulnerabilities"`
}

// GitHubCVSS represents CVSS info.
type GitHubCVSS struct {
	Score        float64 `json:"score"`
	VectorString string  `json:"vectorString"`
}

// GitHubIdentifier represents an advisory identifier.
type GitHubIdentifier struct {
	Type  string `json:"type"`  // CVE, GHSA
	Value string `json:"value"`
}

// GitHubReference represents a reference URL.
type GitHubReference struct {
	URL string `json:"url"`
}

// GitHubVulnerabilitiesConn represents the vulnerabilities connection.
type GitHubVulnerabilitiesConn struct {
	Nodes []GitHubVulnerability `json:"nodes"`
}

// GitHubVulnerability represents a vulnerable package.
type GitHubVulnerability struct {
	Package                 GitHubPackage          `json:"package"`
	VulnerableVersionRange  string                 `json:"vulnerableVersionRange"`
	FirstPatchedVersion     *GitHubPatchedVersion  `json:"firstPatchedVersion"`
}

// GitHubPackage represents an affected package.
type GitHubPackage struct {
	Ecosystem string `json:"ecosystem"`
	Name      string `json:"name"`
}

// GitHubPatchedVersion represents a patched version.
type GitHubPatchedVersion struct {
	Identifier string `json:"identifier"`
}
