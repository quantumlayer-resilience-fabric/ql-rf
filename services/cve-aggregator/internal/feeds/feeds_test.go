package feeds

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"log/slog"
	"os"
)

func testLogger() *slog.Logger {
	return slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
}

// =============================================================================
// Feed Manager Tests
// =============================================================================

func TestFeedManager_RegisterFeed(t *testing.T) {
	manager := NewFeedManager()

	nvdFeed := NewNVDFeed("", testLogger())
	config := FeedConfig{
		Enabled:      true,
		PollInterval: 15 * time.Minute,
		RateLimit:    30,
		BatchSize:    100,
		Timeout:      60 * time.Second,
		RetryCount:   3,
		RetryBackoff: 5 * time.Second,
	}

	manager.RegisterFeed(nvdFeed, config)

	feeds := manager.GetEnabledFeeds()
	if len(feeds) != 1 {
		t.Errorf("expected 1 enabled feed, got %d", len(feeds))
	}

	if feeds[0].Name() != "nvd" {
		t.Errorf("expected feed name 'nvd', got '%s'", feeds[0].Name())
	}
}

func TestFeedManager_GetConfig(t *testing.T) {
	manager := NewFeedManager()

	nvdFeed := NewNVDFeed("", testLogger())
	config := FeedConfig{
		Enabled:      true,
		PollInterval: 15 * time.Minute,
		RateLimit:    30,
	}

	manager.RegisterFeed(nvdFeed, config)

	retrieved, ok := manager.GetConfig("nvd")
	if !ok {
		t.Fatal("expected to find config for 'nvd'")
	}

	if retrieved.PollInterval != 15*time.Minute {
		t.Errorf("expected poll interval 15m, got %v", retrieved.PollInterval)
	}
}

func TestFeedManager_DisabledFeed(t *testing.T) {
	manager := NewFeedManager()

	nvdFeed := NewNVDFeed("", testLogger())
	config := FeedConfig{
		Enabled: false,
	}

	manager.RegisterFeed(nvdFeed, config)

	feeds := manager.GetEnabledFeeds()
	if len(feeds) != 0 {
		t.Errorf("expected 0 enabled feeds, got %d", len(feeds))
	}
}

// =============================================================================
// NVD Feed Tests
// =============================================================================

func TestNVDFeed_Name(t *testing.T) {
	feed := NewNVDFeed("", testLogger())
	if feed.Name() != "nvd" {
		t.Errorf("expected name 'nvd', got '%s'", feed.Name())
	}
}

func TestNVDFeed_DisplayName(t *testing.T) {
	feed := NewNVDFeed("", testLogger())
	expected := "NVD (National Vulnerability Database)"
	if feed.DisplayName() != expected {
		t.Errorf("expected display name '%s', got '%s'", expected, feed.DisplayName())
	}
}

func TestNVDFeed_Priority(t *testing.T) {
	feed := NewNVDFeed("", testLogger())
	if feed.Priority() != 10 {
		t.Errorf("expected priority 10, got %d", feed.Priority())
	}
}

func TestNVDFeed_HealthCheck(t *testing.T) {
	// Note: actual health check would require mocking the NVD API
	// This test just verifies the feed can be constructed
	feed := NewNVDFeed("", testLogger())
	if feed == nil {
		t.Error("expected non-nil feed")
	}
}

func TestNVDFeed_ConvertToCVECache(t *testing.T) {
	feed := NewNVDFeed("", testLogger())

	// Test conversion with CVSS v3.1 data
	vuln := NVDVulnerability{
		CVE: NVDCVE{
			ID:           "CVE-2024-1234",
			Published:    "2024-01-15T10:00:00.000Z",
			LastModified: "2024-01-16T10:00:00.000Z",
			Descriptions: []NVDDescription{
				{Lang: "en", Value: "Test vulnerability description"},
			},
			Metrics: &NVDMetrics{
				CVSSV31: []NVDCVSSMetric{
					{
						CVSSData: NVDCVSSData{
							Version:      "3.1",
							VectorString: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
							BaseScore:    9.8,
							BaseSeverity: "CRITICAL",
						},
					},
				},
			},
		},
	}

	cve := feed.convertToCVECache(vuln.CVE)

	if cve.CVEID != "CVE-2024-1234" {
		t.Errorf("expected CVE ID 'CVE-2024-1234', got '%s'", cve.CVEID)
	}

	if cve.Severity != "critical" {
		t.Errorf("expected severity 'critical', got '%s'", cve.Severity)
	}

	if cve.CVSSV3Score == nil || *cve.CVSSV3Score != 9.8 {
		t.Errorf("expected CVSS score 9.8, got %v", cve.CVSSV3Score)
	}

	if cve.Description == nil || *cve.Description != "Test vulnerability description" {
		t.Errorf("expected description, got %v", cve.Description)
	}

	if cve.PrimarySource != "nvd" {
		t.Errorf("expected primary source 'nvd', got '%s'", cve.PrimarySource)
	}
}

// =============================================================================
// CISA KEV Feed Tests
// =============================================================================

func TestCISAKEVFeed_Name(t *testing.T) {
	feed := NewCISAKEVFeed(testLogger())
	if feed.Name() != "cisa_kev" {
		t.Errorf("expected name 'cisa_kev', got '%s'", feed.Name())
	}
}

func TestCISAKEVFeed_Priority(t *testing.T) {
	feed := NewCISAKEVFeed(testLogger())
	// CISA KEV should have highest priority (lowest number)
	if feed.Priority() != 5 {
		t.Errorf("expected priority 5, got %d", feed.Priority())
	}
}

func TestCISAKEVFeed_FetchCVEs(t *testing.T) {
	mockResponse := CISAKEVResponse{
		Title:          "CISA Known Exploited Vulnerabilities Catalog",
		CatalogVersion: "2024.01.15",
		Count:          1,
		Vulnerabilities: []CISAKEVVulnerability{
			{
				CVEID:                      "CVE-2024-5678",
				VendorProject:              "TestVendor",
				Product:                    "TestProduct",
				VulnerabilityName:          "Test KEV Vulnerability",
				DateAdded:                  "2024-01-15",
				ShortDescription:           "A critical vulnerability being actively exploited",
				RequiredAction:             "Apply vendor patch",
				DueDate:                    "2024-02-15",
				KnownRansomwareCampaignUse: "Known",
			},
		},
	}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(mockResponse)
	}))
	defer server.Close()

	feed := &CISAKEVFeed{
		httpClient: &http.Client{Timeout: 5 * time.Second},
		logger:     testLogger(),
	}

	// Override the URL for testing (we'd need to make this configurable in production)
	// For now, test the conversion logic directly
	cve := feed.convertToCVECache(mockResponse.Vulnerabilities[0])

	if cve.CVEID != "CVE-2024-5678" {
		t.Errorf("expected CVE ID 'CVE-2024-5678', got '%s'", cve.CVEID)
	}

	if !cve.CISAKEVListed {
		t.Error("expected CISAKEVListed to be true")
	}

	if !cve.ExploitAvailable {
		t.Error("expected ExploitAvailable to be true for KEV CVE")
	}

	if cve.CISAKEVRansomware == nil || !*cve.CISAKEVRansomware {
		t.Error("expected CISAKEVRansomware to be true")
	}

	if cve.Severity != "critical" {
		t.Errorf("expected severity 'critical' for KEV CVE, got '%s'", cve.Severity)
	}
}

// =============================================================================
// OSV Feed Tests
// =============================================================================

func TestOSVFeed_Name(t *testing.T) {
	feed := NewOSVFeed(testLogger())
	if feed.Name() != "osv" {
		t.Errorf("expected name 'osv', got '%s'", feed.Name())
	}
}

func TestOSVFeed_DisplayName(t *testing.T) {
	feed := NewOSVFeed(testLogger())
	expected := "OSV (Open Source Vulnerabilities)"
	if feed.DisplayName() != expected {
		t.Errorf("expected display name '%s', got '%s'", expected, feed.DisplayName())
	}
}

func TestOSVFeed_Priority(t *testing.T) {
	feed := NewOSVFeed(testLogger())
	if feed.Priority() != 20 {
		t.Errorf("expected priority 20, got %d", feed.Priority())
	}
}

func TestOSVFeed_QueryByPackage(t *testing.T) {
	mockResponse := OSVQueryResponse{
		Vulns: []OSVVulnerability{
			{
				ID:        "GHSA-xxxx-yyyy-zzzz",
				Summary:   "Test vulnerability in test-package",
				Published: "2024-01-15T10:00:00Z",
				Modified:  "2024-01-16T10:00:00Z",
				Aliases:   []string{"CVE-2024-9999"},
				Severity: []OSVSeverity{
					{Type: "CVSS_V3", Score: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"},
				},
			},
		},
	}

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			t.Errorf("expected POST request, got %s", r.Method)
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(mockResponse)
	}))
	defer server.Close()

	feed := &OSVFeed{
		httpClient: &http.Client{Timeout: 5 * time.Second},
		logger:     testLogger(),
	}

	// Test conversion
	cve := feed.convertToCVECache(mockResponse.Vulns[0])

	// Should use CVE alias over GHSA ID
	if cve.CVEID != "CVE-2024-9999" {
		t.Errorf("expected CVE ID 'CVE-2024-9999', got '%s'", cve.CVEID)
	}

	if cve.PrimarySource != "osv" {
		t.Errorf("expected primary source 'osv', got '%s'", cve.PrimarySource)
	}
}

// =============================================================================
// GitHub Advisory Feed Tests
// =============================================================================

func TestGitHubAdvisoryFeed_Name(t *testing.T) {
	feed := NewGitHubAdvisoryFeed("test-token", testLogger())
	if feed.Name() != "github" {
		t.Errorf("expected name 'github', got '%s'", feed.Name())
	}
}

func TestGitHubAdvisoryFeed_DisplayName(t *testing.T) {
	feed := NewGitHubAdvisoryFeed("test-token", testLogger())
	expected := "GitHub Security Advisories"
	if feed.DisplayName() != expected {
		t.Errorf("expected display name '%s', got '%s'", expected, feed.DisplayName())
	}
}

func TestGitHubAdvisoryFeed_Priority(t *testing.T) {
	feed := NewGitHubAdvisoryFeed("test-token", testLogger())
	if feed.Priority() != 15 {
		t.Errorf("expected priority 15, got %d", feed.Priority())
	}
}

func TestGitHubAdvisoryFeed_HealthCheckNoToken(t *testing.T) {
	feed := NewGitHubAdvisoryFeed("", testLogger())
	err := feed.HealthCheck(context.Background())
	if err == nil {
		t.Error("expected error for missing token")
	}
}

func TestGitHubAdvisoryFeed_FetchCVEsNoToken(t *testing.T) {
	feed := NewGitHubAdvisoryFeed("", testLogger())
	cves, err := feed.FetchCVEs(context.Background(), time.Now().Add(-24*time.Hour))
	if err != nil {
		t.Errorf("expected no error for missing token, got %v", err)
	}
	if len(cves) != 0 {
		t.Errorf("expected 0 CVEs for missing token, got %d", len(cves))
	}
}

func TestGitHubAdvisoryFeed_ConvertToCVECache(t *testing.T) {
	feed := NewGitHubAdvisoryFeed("test-token", testLogger())

	advisory := GitHubAdvisory{
		GHSAId:      "GHSA-abcd-1234-efgh",
		Summary:     "Test vulnerability summary",
		Description: "Test vulnerability description",
		Severity:    "CRITICAL",
		PublishedAt: "2024-01-15T10:00:00Z",
		UpdatedAt:   "2024-01-16T10:00:00Z",
		CVSS: GitHubCVSS{
			Score:        9.8,
			VectorString: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
		},
		Identifiers: []GitHubIdentifier{
			{Type: "GHSA", Value: "GHSA-abcd-1234-efgh"},
			{Type: "CVE", Value: "CVE-2024-1111"},
		},
	}

	cve := feed.convertToCVECache(advisory)

	// Should prefer CVE over GHSA
	if cve.CVEID != "CVE-2024-1111" {
		t.Errorf("expected CVE ID 'CVE-2024-1111', got '%s'", cve.CVEID)
	}

	if cve.PrimarySource != "github" {
		t.Errorf("expected primary source 'github', got '%s'", cve.PrimarySource)
	}

	if cve.CVSSV3Score == nil || *cve.CVSSV3Score != 9.8 {
		t.Errorf("expected CVSS score 9.8, got %v", cve.CVSSV3Score)
	}

	if cve.Description == nil || *cve.Description != "Test vulnerability summary" {
		t.Errorf("expected description 'Test vulnerability summary', got %v", cve.Description)
	}
}

// =============================================================================
// Feed Interface Tests
// =============================================================================

func TestAllFeeds_ImplementInterface(t *testing.T) {
	logger := testLogger()

	// Verify all feeds implement the Feed interface
	var _ Feed = NewNVDFeed("", logger)
	var _ Feed = NewCISAKEVFeed(logger)
	var _ Feed = NewOSVFeed(logger)
	var _ Feed = NewGitHubAdvisoryFeed("", logger)
}

// =============================================================================
// Integration-style Tests (with mock servers)
// =============================================================================

func TestNVDFeed_RateLimitingWithKey(t *testing.T) {
	feed := NewNVDFeed("test-api-key", testLogger())
	// With API key, delay should be 600ms
	if feed.apiKey != "test-api-key" {
		t.Errorf("expected API key to be set")
	}
}

func TestNVDFeed_RateLimitingWithoutKey(t *testing.T) {
	feed := NewNVDFeed("", testLogger())
	// Without API key, delay should be 6 seconds
	if feed.apiKey != "" {
		t.Errorf("expected API key to be empty")
	}
}
